var searchIndex = {};
searchIndex["std"] = {"doc":"","items":[[0,"any","std","This module implements the `Any` trait, which enables dynamic typing of any `'static` type through runtime reflection.",null,null],[8,"Any","std::any","A type to emulate dynamic typing.",null,null],[10,"get_type_id","","Gets the `TypeId` of `self`.",0,{"inputs":[{"name":"self"}],"output":{"name":"typeid"}}],[3,"TypeId","","A `TypeId` represents a globally unique identifier for a type.",null,null],[0,"cell","std","Shareable mutable containers.",null,null],[3,"Cell","std::cell","A mutable memory location.",null,null],[3,"RefCell","","A mutable memory location with dynamically checked borrow rules",null,null],[3,"BorrowError","","An error returned by `RefCell::try_borrow`.",null,null],[3,"BorrowMutError","","An error returned by `RefCell::try_borrow_mut`.",null,null],[3,"Ref","","Wraps a borrowed reference to a value in a `RefCell` box. A wrapper type for an immutably borrowed value from a `RefCell<T>`.",null,null],[3,"RefMut","","A wrapper type for a mutably borrowed value from a `RefCell<T>`.",null,null],[3,"UnsafeCell","","The core primitive for interior mutability in Rust.",null,null],[0,"clone","std","The `Clone` trait for types that cannot be 'implicitly copied'.",null,null],[8,"Clone","std::clone","A common trait for the ability to explicitly duplicate an object.",null,null],[10,"clone","","Returns a copy of the value.",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone_from","","Performs copy-assignment from `source`.",1,null],[0,"cmp","std","Functionality for ordering and comparison.",null,null],[8,"PartialEq","std::cmp","Trait for equality comparisons which are partial equivalence relations.",null,null],[10,"eq","","This method tests for `self` and `other` values to be equal, and is used by `==`.",2,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"ne","","This method tests for `!=`.",2,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[8,"Eq","","Trait for equality comparisons which are equivalence relations.",null,null],[4,"Ordering","","An `Ordering` is the result of a comparison between two values.",null,null],[13,"Less","","An ordering where a compared value is less [than another].",3,null],[13,"Equal","","An ordering where a compared value is equal [to another].",3,null],[13,"Greater","","An ordering where a compared value is greater [than another].",3,null],[3,"Reverse","","A helper struct for reverse ordering.",null,null],[12,"0","","",4,null],[8,"Ord","","Trait for types that form a total order.",null,null],[10,"cmp","","This method returns an `Ordering` between `self` and `other`.",5,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"max","","Compares and returns the maximum of two values.",5,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"min","","Compares and returns the minimum of two values.",5,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"PartialOrd","","Trait for values that can be compared for a sort-order.",null,null],[10,"partial_cmp","","This method returns an ordering between `self` and `other` values if one exists.",6,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","This method tests less than (for `self` and `other`) and is used by the `<` operator.",6,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"le","","This method tests less than or equal to (for `self` and `other`) and is used by the `<=` operator.",6,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"gt","","This method tests greater than (for `self` and `other`) and is used by the `>` operator.",6,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[11,"ge","","This method tests greater than or equal to (for `self` and `other`) and is used by the `>=` operator.",6,{"inputs":[{"name":"self"},{"name":"rhs"}],"output":{"name":"bool"}}],[5,"min","","Compares and returns the minimum of two values.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"max","","Compares and returns the maximum of two values.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[0,"convert","std","Traits for conversions between types.",null,null],[4,"Infallible","std::convert","A type used as the error type for implementations of fallible conversion traits in cases where conversions cannot actually fail.",null,null],[8,"AsRef","","A cheap reference-to-reference conversion. Used to convert a value to a reference value within generic code.",null,null],[10,"as_ref","","Performs the conversion.",7,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"AsMut","","A cheap, mutable reference-to-mutable reference conversion.",null,null],[10,"as_mut","","Performs the conversion.",8,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"Into","","A conversion that consumes `self`, which may or may not be expensive. The reciprocal of [`From`][From].",null,null],[10,"into","","Performs the conversion.",9,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[8,"From","","Simple and safe type conversions in to `Self`. It is the reciprocal of `Into`.",null,null],[10,"from","","Performs the conversion.",10,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[8,"TryInto","","An attempted conversion that consumes `self`, which may or may not be expensive.",null,null],[16,"Error","","The type returned in the event of a conversion error.",11,null],[10,"try_into","","Performs the conversion.",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[8,"TryFrom","","Attempt to construct `Self` via a conversion.",null,null],[16,"Error","","The type returned in the event of a conversion error.",12,null],[10,"try_from","","Performs the conversion.",12,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[0,"default","std","The `Default` trait for types which may have meaningful default values.",null,null],[8,"Default","std::default","A trait for giving a type a useful default value.",null,null],[10,"default","","Returns the \"default value\" for a type.",13,{"inputs":[],"output":{"name":"self"}}],[0,"hash","std","Generic hashing support.",null,null],[8,"Hash","std::hash","A hashable type.",null,null],[10,"hash","","Feeds this value into the given [`Hasher`].",14,null],[11,"hash_slice","","Feeds a slice of this type into the given [`Hasher`].",14,null],[8,"Hasher","","A trait for hashing an arbitrary stream of bytes.",null,null],[10,"finish","","Returns the hash value for the values written so far.",15,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[10,"write","","Writes some data into this `Hasher`.",15,null],[11,"write_u8","","Writes a single `u8` into this hasher.",15,null],[11,"write_u16","","Writes a single `u16` into this hasher.",15,null],[11,"write_u32","","Writes a single `u32` into this hasher.",15,null],[11,"write_u64","","Writes a single `u64` into this hasher.",15,null],[11,"write_u128","","Writes a single `u128` into this hasher.",15,null],[11,"write_usize","","Writes a single `usize` into this hasher.",15,null],[11,"write_i8","","Writes a single `i8` into this hasher.",15,null],[11,"write_i16","","Writes a single `i16` into this hasher.",15,null],[11,"write_i32","","Writes a single `i32` into this hasher.",15,null],[11,"write_i64","","Writes a single `i64` into this hasher.",15,null],[11,"write_i128","","Writes a single `i128` into this hasher.",15,null],[11,"write_isize","","Writes a single `isize` into this hasher.",15,null],[8,"BuildHasher","","A trait for creating instances of [`Hasher`].",null,null],[16,"Hasher","","Type of the hasher that will be created.",16,null],[10,"build_hasher","","Creates a new hasher.",16,null],[3,"BuildHasherDefault","","Used to create a default [`BuildHasher`] instance for types that implement [`Hasher`] and [`Default`].",null,null],[3,"SipHasher","","An implementation of SipHash 2-4.",null,null],[3,"SipHasher24","","An implementation of SipHash 2-4.",null,null],[3,"SipHasher13","","An implementation of SipHash 1-3.",null,null],[0,"intrinsics","std","rustc compiler intrinsics.",null,null],[5,"atomic_cxchg","std::intrinsics","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::SeqCst` as both the `success` and `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_acq","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::Acquire` as both the `success` and `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_rel","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::Release` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_acqrel","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::AcqRel` as the `success` and `Ordering::Acquire` as the `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_relaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::Relaxed` as both the `success` and `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_failrelaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::SeqCst` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_failacq","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::SeqCst` as the `success` and `Ordering::Acquire` as the `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_acq_failrelaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::Acquire` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchg_acqrel_failrelaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange` method by passing `Ordering::AcqRel` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange`][compare_exchange].",null,null],[5,"atomic_cxchgweak","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::SeqCst` as both the `success` and `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_acq","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::Acquire` as both the `success` and `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_rel","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::Release` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_acqrel","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::AcqRel` as the `success` and `Ordering::Acquire` as the `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_relaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::Relaxed` as both the `success` and `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_failrelaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::SeqCst` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_failacq","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::SeqCst` as the `success` and `Ordering::Acquire` as the `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_acq_failrelaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::Acquire` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_cxchgweak_acqrel_failrelaxed","","Stores a value if the current value is the same as the `old` value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `compare_exchange_weak` method by passing `Ordering::AcqRel` as the `success` and `Ordering::Relaxed` as the `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`][cew].",null,null],[5,"atomic_load","","Loads the current value of the pointer. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `load` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::load`.",null,null],[5,"atomic_load_acq","","Loads the current value of the pointer. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `load` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicBool::load`.",null,null],[5,"atomic_load_relaxed","","Loads the current value of the pointer. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `load` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::load`.",null,null],[5,"atomic_load_unordered","","",null,null],[5,"atomic_store","","Stores the value at the specified memory location. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `store` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::store`.",null,null],[5,"atomic_store_rel","","Stores the value at the specified memory location. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `store` method by passing `Ordering::Release` as the `order`. For example, `AtomicBool::store`.",null,null],[5,"atomic_store_relaxed","","Stores the value at the specified memory location. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `store` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::store`.",null,null],[5,"atomic_store_unordered","","",null,null],[5,"atomic_xchg","","Stores the value at the specified memory location, returning the old value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `swap` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::swap`.",null,null],[5,"atomic_xchg_acq","","Stores the value at the specified memory location, returning the old value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `swap` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicBool::swap`.",null,null],[5,"atomic_xchg_rel","","Stores the value at the specified memory location, returning the old value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `swap` method by passing `Ordering::Release` as the `order`. For example, `AtomicBool::swap`.",null,null],[5,"atomic_xchg_acqrel","","Stores the value at the specified memory location, returning the old value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `swap` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicBool::swap`.",null,null],[5,"atomic_xchg_relaxed","","Stores the value at the specified memory location, returning the old value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `swap` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::swap`.",null,null],[5,"atomic_xadd","","Add to the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_add` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicIsize::fetch_add`.",null,null],[5,"atomic_xadd_acq","","Add to the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_add` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicIsize::fetch_add`.",null,null],[5,"atomic_xadd_rel","","Add to the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_add` method by passing `Ordering::Release` as the `order`. For example, `AtomicIsize::fetch_add`.",null,null],[5,"atomic_xadd_acqrel","","Add to the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_add` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicIsize::fetch_add`.",null,null],[5,"atomic_xadd_relaxed","","Add to the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_add` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicIsize::fetch_add`.",null,null],[5,"atomic_xsub","","Subtract from the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_sub` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicIsize::fetch_sub`.",null,null],[5,"atomic_xsub_acq","","Subtract from the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_sub` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicIsize::fetch_sub`.",null,null],[5,"atomic_xsub_rel","","Subtract from the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_sub` method by passing `Ordering::Release` as the `order`. For example, `AtomicIsize::fetch_sub`.",null,null],[5,"atomic_xsub_acqrel","","Subtract from the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_sub` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicIsize::fetch_sub`.",null,null],[5,"atomic_xsub_relaxed","","Subtract from the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_sub` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicIsize::fetch_sub`.",null,null],[5,"atomic_and","","Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_and` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::fetch_and`.",null,null],[5,"atomic_and_acq","","Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_and` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicBool::fetch_and`.",null,null],[5,"atomic_and_rel","","Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_and` method by passing `Ordering::Release` as the `order`. For example, `AtomicBool::fetch_and`.",null,null],[5,"atomic_and_acqrel","","Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_and` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicBool::fetch_and`.",null,null],[5,"atomic_and_relaxed","","Bitwise and with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_and` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::fetch_and`.",null,null],[5,"atomic_nand","","Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::fetch_nand`.",null,null],[5,"atomic_nand_acq","","Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicBool::fetch_nand`.",null,null],[5,"atomic_nand_rel","","Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing `Ordering::Release` as the `order`. For example, `AtomicBool::fetch_nand`.",null,null],[5,"atomic_nand_acqrel","","Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicBool::fetch_nand`.",null,null],[5,"atomic_nand_relaxed","","Bitwise nand with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::fetch_nand`.",null,null],[5,"atomic_or","","Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_or` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::fetch_or`.",null,null],[5,"atomic_or_acq","","Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_or` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicBool::fetch_or`.",null,null],[5,"atomic_or_rel","","Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_or` method by passing `Ordering::Release` as the `order`. For example, `AtomicBool::fetch_or`.",null,null],[5,"atomic_or_acqrel","","Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_or` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicBool::fetch_or`.",null,null],[5,"atomic_or_relaxed","","Bitwise or with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_or` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::fetch_or`.",null,null],[5,"atomic_xor","","Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_xor` method by passing `Ordering::SeqCst` as the `order`. For example, `AtomicBool::fetch_xor`.",null,null],[5,"atomic_xor_acq","","Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_xor` method by passing `Ordering::Acquire` as the `order`. For example, `AtomicBool::fetch_xor`.",null,null],[5,"atomic_xor_rel","","Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_xor` method by passing `Ordering::Release` as the `order`. For example, `AtomicBool::fetch_xor`.",null,null],[5,"atomic_xor_acqrel","","Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_xor` method by passing `Ordering::AcqRel` as the `order`. For example, `AtomicBool::fetch_xor`.",null,null],[5,"atomic_xor_relaxed","","Bitwise xor with the current value, returning the previous value. The stabilized version of this intrinsic is available on the `std::sync::atomic` types via the `fetch_xor` method by passing `Ordering::Relaxed` as the `order`. For example, `AtomicBool::fetch_xor`.",null,null],[5,"atomic_max","","",null,null],[5,"atomic_max_acq","","",null,null],[5,"atomic_max_rel","","",null,null],[5,"atomic_max_acqrel","","",null,null],[5,"atomic_max_relaxed","","",null,null],[5,"atomic_min","","",null,null],[5,"atomic_min_acq","","",null,null],[5,"atomic_min_rel","","",null,null],[5,"atomic_min_acqrel","","",null,null],[5,"atomic_min_relaxed","","",null,null],[5,"atomic_umin","","",null,null],[5,"atomic_umin_acq","","",null,null],[5,"atomic_umin_rel","","",null,null],[5,"atomic_umin_acqrel","","",null,null],[5,"atomic_umin_relaxed","","",null,null],[5,"atomic_umax","","",null,null],[5,"atomic_umax_acq","","",null,null],[5,"atomic_umax_rel","","",null,null],[5,"atomic_umax_acqrel","","",null,null],[5,"atomic_umax_relaxed","","",null,null],[5,"prefetch_read_data","","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a noop. Prefetches have no effect on the behavior of the program but can change its performance characteristics.",null,null],[5,"prefetch_write_data","","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a noop. Prefetches have no effect on the behavior of the program but can change its performance characteristics.",null,null],[5,"prefetch_read_instruction","","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a noop. Prefetches have no effect on the behavior of the program but can change its performance characteristics.",null,null],[5,"prefetch_write_instruction","","The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a noop. Prefetches have no effect on the behavior of the program but can change its performance characteristics.",null,null],[5,"atomic_fence","","",null,null],[5,"atomic_fence_acq","","",null,null],[5,"atomic_fence_rel","","",null,null],[5,"atomic_fence_acqrel","","",null,null],[5,"atomic_singlethreadfence","","A compiler-only memory barrier.",null,null],[5,"atomic_singlethreadfence_acq","","",null,null],[5,"atomic_singlethreadfence_rel","","",null,null],[5,"atomic_singlethreadfence_acqrel","","",null,null],[5,"rustc_peek","","Magic intrinsic that derives its meaning from attributes attached to the function.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"abort","","Aborts the execution of the process.",null,null],[5,"unreachable","","Tells LLVM that this point in the code is not reachable, enabling further optimizations.",null,null],[5,"assume","","Informs the optimizer that a condition is always true. If the condition is false, the behavior is undefined.",null,null],[5,"likely","","Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.",null,{"inputs":[{"name":"bool"}],"output":{"name":"bool"}}],[5,"unlikely","","Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.",null,{"inputs":[{"name":"bool"}],"output":{"name":"bool"}}],[5,"breakpoint","","Executes a breakpoint trap, for inspection by a debugger.",null,null],[5,"size_of","","The size of a type in bytes.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"move_val_init","","Moves a value to an uninitialized memory location.",null,null],[5,"min_align_of","","",null,{"inputs":[],"output":{"name":"usize"}}],[5,"pref_align_of","","",null,{"inputs":[],"output":{"name":"usize"}}],[5,"size_of_val","","The size of the referenced value in bytes.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"min_align_of_val","","",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"type_name","","Gets a static string slice containing the name of a type.",null,{"inputs":[],"output":{"name":"str"}}],[5,"type_id","","Gets an identifier which is globally unique to the specified type. This function will return the same value for a type regardless of whichever crate it is invoked in.",null,{"inputs":[],"output":{"name":"u64"}}],[5,"init","","Creates a value initialized to zero.",null,{"inputs":[],"output":{"name":"t"}}],[5,"uninit","","Creates an uninitialized value.",null,{"inputs":[],"output":{"name":"t"}}],[5,"transmute","","Reinterprets the bits of a value of one type as another type.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[5,"needs_drop","","Returns `true` if the actual type given as `T` requires drop glue; returns `false` if the actual type provided for `T` implements `Copy`.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"offset","","Calculates the offset from a pointer.",null,null],[5,"arith_offset","","Calculates the offset from a pointer, potentially wrapping.",null,null],[5,"copy_nonoverlapping","","Copies `count * size_of<T>` bytes from `src` to `dst`. The source and destination may not overlap.",null,null],[5,"copy","","Copies `count * size_of<T>` bytes from `src` to `dst`. The source and destination may overlap.",null,null],[5,"write_bytes","","Invokes memset on the specified pointer, setting `count * size_of::<T>()` bytes of memory starting at `dst` to `val`.",null,null],[5,"volatile_copy_nonoverlapping_memory","","Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`",null,null],[5,"volatile_copy_memory","","Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`",null,null],[5,"volatile_set_memory","","Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`.",null,null],[5,"volatile_load","","Perform a volatile load from the `src` pointer. The stabilized version of this intrinsic is `std::ptr::read_volatile`.",null,null],[5,"volatile_store","","Perform a volatile store to the `dst` pointer. The stabilized version of this intrinsic is `std::ptr::write_volatile`.",null,null],[5,"sqrtf32","","Returns the square root of an `f32`",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"sqrtf64","","Returns the square root of an `f64`",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"powif32","","Raises an `f32` to an integer power.",null,{"inputs":[{"name":"f32"},{"name":"i32"}],"output":{"name":"f32"}}],[5,"powif64","","Raises an `f64` to an integer power.",null,{"inputs":[{"name":"f64"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"sinf32","","Returns the sine of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"sinf64","","Returns the sine of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"cosf32","","Returns the cosine of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"cosf64","","Returns the cosine of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"powf32","","Raises an `f32` to an `f32` power.",null,{"inputs":[{"name":"f32"},{"name":"f32"}],"output":{"name":"f32"}}],[5,"powf64","","Raises an `f64` to an `f64` power.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"expf32","","Returns the exponential of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"expf64","","Returns the exponential of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"exp2f32","","Returns 2 raised to the power of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"exp2f64","","Returns 2 raised to the power of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"logf32","","Returns the natural logarithm of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"logf64","","Returns the natural logarithm of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log10f32","","Returns the base 10 logarithm of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"log10f64","","Returns the base 10 logarithm of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log2f32","","Returns the base 2 logarithm of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"log2f64","","Returns the base 2 logarithm of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fmaf32","","Returns `a * b + c` for `f32` values.",null,{"inputs":[{"name":"f32"},{"name":"f32"},{"name":"f32"}],"output":{"name":"f32"}}],[5,"fmaf64","","Returns `a * b + c` for `f64` values.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fabsf32","","Returns the absolute value of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"fabsf64","","Returns the absolute value of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"copysignf32","","Copies the sign from `y` to `x` for `f32` values.",null,{"inputs":[{"name":"f32"},{"name":"f32"}],"output":{"name":"f32"}}],[5,"copysignf64","","Copies the sign from `y` to `x` for `f64` values.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"floorf32","","Returns the largest integer less than or equal to an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"floorf64","","Returns the largest integer less than or equal to an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"ceilf32","","Returns the smallest integer greater than or equal to an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"ceilf64","","Returns the smallest integer greater than or equal to an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"truncf32","","Returns the integer part of an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"truncf64","","Returns the integer part of an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"rintf32","","Returns the nearest integer to an `f32`. May raise an inexact floating-point exception if the argument is not an integer.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"rintf64","","Returns the nearest integer to an `f64`. May raise an inexact floating-point exception if the argument is not an integer.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"nearbyintf32","","Returns the nearest integer to an `f32`.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"nearbyintf64","","Returns the nearest integer to an `f64`.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"roundf32","","Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.",null,{"inputs":[{"name":"f32"}],"output":{"name":"f32"}}],[5,"roundf64","","Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fadd_fast","","Float addition that allows optimizations based on algebraic rules. May assume inputs are finite.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"fsub_fast","","Float subtraction that allows optimizations based on algebraic rules. May assume inputs are finite.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"fmul_fast","","Float multiplication that allows optimizations based on algebraic rules. May assume inputs are finite.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"fdiv_fast","","Float division that allows optimizations based on algebraic rules. May assume inputs are finite.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"frem_fast","","Float remainder that allows optimizations based on algebraic rules. May assume inputs are finite.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"ctpop","","Returns the number of bits set in an integer type `T`",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"ctlz","","Returns the number of leading unset bits (zeroes) in an integer type `T`.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"ctlz_nonzero","","Like `ctlz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"cttz","","Returns the number of trailing unset bits (zeroes) in an integer type `T`.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"cttz_nonzero","","Like `cttz`, but extra-unsafe as it returns `undef` when given an `x` with value `0`.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"bswap","","Reverses the bytes in an integer type `T`.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"add_with_overflow","","Performs checked integer addition. The stabilized versions of this intrinsic are available on the integer primitives via the `overflowing_add` method. For example, `std::u32::overflowing_add`",null,null],[5,"sub_with_overflow","","Performs checked integer subtraction The stabilized versions of this intrinsic are available on the integer primitives via the `overflowing_sub` method. For example, `std::u32::overflowing_sub`",null,null],[5,"mul_with_overflow","","Performs checked integer multiplication The stabilized versions of this intrinsic are available on the integer primitives via the `overflowing_mul` method. For example, `std::u32::overflowing_mul`",null,null],[5,"unchecked_div","","Performs an unchecked division, resulting in undefined behavior where y = 0 or x = `T::min_value()` and y = -1",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"unchecked_rem","","Returns the remainder of an unchecked division, resulting in undefined behavior where y = 0 or x = `T::min_value()` and y = -1",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"unchecked_shl","","Performs an unchecked left shift, resulting in undefined behavior when y < 0 or y >= N, where N is the width of T in bits.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"unchecked_shr","","Performs an unchecked right shift, resulting in undefined behavior when y < 0 or y >= N, where N is the width of T in bits.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"overflowing_add","","Returns (a + b) mod 2N, where N is the width of T in bits. The stabilized versions of this intrinsic are available on the integer primitives via the `wrapping_add` method. For example, `std::u32::wrapping_add`",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"overflowing_sub","","Returns (a - b) mod 2N, where N is the width of T in bits. The stabilized versions of this intrinsic are available on the integer primitives via the `wrapping_sub` method. For example, `std::u32::wrapping_sub`",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"overflowing_mul","","Returns (a * b) mod 2N, where N is the width of T in bits. The stabilized versions of this intrinsic are available on the integer primitives via the `wrapping_mul` method. For example, `std::u32::wrapping_mul`",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"discriminant_value","","Returns the value of the discriminant for the variant in 'v', cast to a `u64`; if `T` has no discriminant, returns 0.",null,{"inputs":[{"name":"t"}],"output":{"name":"u64"}}],[5,"try","","Rust's \"try catch\" construct which invokes the function pointer `f` with the data pointer `data`.",null,null],[5,"align_offset","","Computes the byte offset that needs to be applied to `ptr` in order to make it aligned to `align`. If it is not possible to align `ptr`, the implementation returns `usize::max_value()`.",null,null],[5,"nontemporal_store","","Emits a `!nontemporal` store according to LLVM (see their docs). Probably will never become stable.",null,null],[5,"drop_in_place","","Executes the destructor (if any) of the pointed-to value.",null,null],[0,"iter","std","Composable external iteration.",null,null],[3,"Rev","std::iter","A double-ended iterator with the direction inverted.",null,null],[3,"Cloned","","An iterator that clones the elements of an underlying iterator.",null,null],[3,"Cycle","","An iterator that repeats endlessly.",null,null],[3,"StepBy","","An iterator for stepping iterators by a custom amount.",null,null],[3,"Chain","","An iterator that strings two iterators together.",null,null],[3,"Zip","","An iterator that iterates two other iterators simultaneously.",null,null],[3,"Map","","An iterator that maps the values of `iter` with `f`.",null,null],[3,"Filter","","An iterator that filters the elements of `iter` with `predicate`.",null,null],[3,"FilterMap","","An iterator that uses `f` to both filter and map elements from `iter`.",null,null],[3,"Enumerate","","An iterator that yields the current count and the element during iteration.",null,null],[3,"Peekable","","An iterator with a `peek()` that returns an optional reference to the next element.",null,null],[3,"SkipWhile","","An iterator that rejects elements while `predicate` is true.",null,null],[3,"TakeWhile","","An iterator that only accepts elements while `predicate` is true.",null,null],[3,"Skip","","An iterator that skips over `n` elements of `iter`.",null,null],[3,"Take","","An iterator that only iterates over the first `n` iterations of `iter`.",null,null],[3,"Scan","","An iterator to maintain state while iterating another iterator.",null,null],[3,"FlatMap","","An iterator that maps each element to an iterator, and yields the elements of the produced iterators.",null,null],[3,"Fuse","","An iterator that yields `None` forever after the underlying iterator yields `None` once.",null,null],[3,"Inspect","","An iterator that calls a function with a reference to each element before yielding it.",null,null],[5,"repeat","","Creates a new iterator that endlessly repeats a single element.",null,{"inputs":[{"name":"t"}],"output":{"name":"repeat"}}],[8,"Iterator","","An interface for dealing with iterators.",null,null],[16,"Item","","The type of the elements being iterated over.",17,null],[10,"next","","Advances the iterator and returns the next value.",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","Returns the bounds on the remaining length of the iterator.",17,null],[11,"count","","Consumes the iterator, counting the number of iterations and returning it.",17,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","Consumes the iterator, returning the last element.",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","Returns the `n`th element of the iterator.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"step_by","","Creates an iterator starting at the same point, but stepping by the given amount at each iteration.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"stepby"}}],[11,"chain","","Takes two iterators and creates a new iterator over both in sequence.",17,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"chain"}}],[11,"zip","","'Zips up' two iterators into a single iterator of pairs.",17,{"inputs":[{"name":"self"},{"name":"u"}],"output":{"name":"zip"}}],[11,"map","","Takes a closure and creates an iterator which calls that closure on each element.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"for_each","","Calls a closure on each element of an iterator.",17,null],[11,"filter","","Creates an iterator which uses a closure to determine if an element should be yielded.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"filter"}}],[11,"filter_map","","Creates an iterator that both filters and maps.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"filtermap"}}],[11,"enumerate","","Creates an iterator which gives the current iteration count as well as the next value.",17,{"inputs":[{"name":"self"}],"output":{"name":"enumerate"}}],[11,"peekable","","Creates an iterator which can use `peek` to look at the next element of the iterator without consuming it.",17,{"inputs":[{"name":"self"}],"output":{"name":"peekable"}}],[11,"skip_while","","Creates an iterator that [`skip`]s elements based on a predicate.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"skipwhile"}}],[11,"take_while","","Creates an iterator that yields elements based on a predicate.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"takewhile"}}],[11,"skip","","Creates an iterator that skips the first `n` elements.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"skip"}}],[11,"take","","Creates an iterator that yields its first `n` elements.",17,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"take"}}],[11,"scan","","An iterator adaptor similar to [`fold`] that holds internal state and produces a new iterator.",17,{"inputs":[{"name":"self"},{"name":"st"},{"name":"f"}],"output":{"name":"scan"}}],[11,"flat_map","","Creates an iterator that works like map, but flattens nested structure.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"flatmap"}}],[11,"fuse","","Creates an iterator which ends after the first [`None`].",17,{"inputs":[{"name":"self"}],"output":{"name":"fuse"}}],[11,"inspect","","Do something with each element of an iterator, passing the value on.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"inspect"}}],[11,"by_ref","","Borrows an iterator, rather than consuming it.",17,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"collect","","Transforms an iterator into a collection.",17,{"inputs":[{"name":"self"}],"output":{"name":"b"}}],[11,"partition","","Consumes an iterator, creating two collections from it.",17,null],[11,"try_fold","","An iterator method that applies a function as long as it returns successfully, producing a single, final value.",17,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","An iterator method that applies a function, producing a single, final value.",17,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[11,"all","","Tests if every element of the iterator matches a predicate.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","Tests if any element of the iterator matches a predicate.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","Searches for an element of an iterator that satisfies a predicate.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"position","","Searches for an element in an iterator, returning its index.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","Searches for an element in an iterator from the right, returning its index.",17,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"max","","Returns the maximum element of an iterator.",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"min","","Returns the minimum element of an iterator.",17,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"max_by_key","","Returns the element that gives the maximum value from the specified function.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"max_by","","Returns the element that gives the maximum value with respect to the specified comparison function.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"min_by_key","","Returns the element that gives the minimum value from the specified function.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"min_by","","Returns the element that gives the minimum value with respect to the specified comparison function.",17,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"rev","","Reverses an iterator's direction.",17,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"unzip","","Converts an iterator of pairs into a pair of containers.",17,null],[11,"cloned","","Creates an iterator which [`clone`]s all of its elements.",17,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"cycle","","Repeats an iterator endlessly.",17,{"inputs":[{"name":"self"}],"output":{"name":"cycle"}}],[11,"sum","","Sums the elements of an iterator.",17,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[11,"product","","Iterates over the entire iterator, multiplying all the elements",17,{"inputs":[{"name":"self"}],"output":{"name":"p"}}],[11,"cmp","","Lexicographically compares the elements of this `Iterator` with those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","Lexicographically compares the elements of this `Iterator` with those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"eq","","Determines if the elements of this `Iterator` are equal to those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"ne","","Determines if the elements of this `Iterator` are unequal to those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"lt","","Determines if the elements of this `Iterator` are lexicographically less than those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"le","","Determines if the elements of this `Iterator` are lexicographically less or equal to those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"gt","","Determines if the elements of this `Iterator` are lexicographically greater than those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[11,"ge","","Determines if the elements of this `Iterator` are lexicographically greater than or equal to those of another.",17,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"bool"}}],[8,"TrustedLen","","An iterator that reports an accurate length using size_hint.",null,null],[8,"FromIterator","","Conversion from an `Iterator`.",null,null],[10,"from_iter","","Creates a value from an iterator.",18,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[8,"IntoIterator","","Conversion into an `Iterator`.",null,null],[16,"Item","","The type of the elements being iterated over.",19,null],[16,"IntoIter","","Which kind of iterator are we turning this into?",19,null],[10,"into_iter","","Creates an iterator from a value.",19,null],[8,"FusedIterator","","An iterator that always continues to yield `None` when exhausted.",null,null],[5,"once","","Creates an iterator that yields an element exactly once.",null,{"inputs":[{"name":"t"}],"output":{"name":"once"}}],[8,"Step","","Objects that can be stepped over in both directions.",null,null],[10,"steps_between","","Returns the number of steps between two step objects. The count is inclusive of `start` and exclusive of `end`.",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[10,"replace_one","","Replaces this step with `1`, returning itself",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"replace_zero","","Replaces this step with `0`, returning itself",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"add_one","","Adds one to this step, returning the result",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"sub_one","","Subtracts one to this step, returning the result",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"add_usize","","Add an usize, returning None on overflow",20,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[8,"DoubleEndedIterator","","An iterator able to yield elements from both ends.",null,null],[10,"next_back","","Removes and returns an element from the end of the iterator.",21,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","This is the reverse version of [`try_fold()`]: it takes elements starting from the back of the iterator.",21,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","An iterator method that reduces the iterator's elements to a single, final value, starting from the back.",21,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[11,"rfind","","Searches for an element of an iterator from the right that satisfies a predicate.",21,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[8,"Product","","Trait to represent types that can be created by multiplying elements of an iterator.",null,null],[10,"product","","Method which takes an iterator and generates `Self` from the elements by multiplying the items.",22,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[3,"Repeat","","An iterator that repeats an element endlessly.",null,null],[3,"Once","","An iterator that yields an element exactly once.",null,null],[8,"Extend","","Extend a collection with the contents of an iterator.",null,null],[10,"extend","","Extends a collection with the contents of an iterator.",23,null],[5,"empty","","Creates an iterator that yields nothing.",null,{"inputs":[],"output":{"name":"empty"}}],[8,"Sum","","Trait to represent types that can be created by summing up an iterator.",null,null],[10,"sum","","Method which takes an iterator and generates `Self` from the elements by \"summing up\" the items.",24,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[3,"Empty","","An iterator that yields nothing.",null,null],[8,"ExactSizeIterator","","An iterator that knows its exact length.",null,null],[11,"len","","Returns the exact number of times the iterator will iterate.",25,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns whether the iterator is empty.",25,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[0,"marker","std","Primitive traits and types representing basic properties of types.",null,null],[8,"Send","std::marker","Types that can be transferred across thread boundaries.",null,null],[8,"Sized","","Types with a constant size known at compile time.",null,null],[8,"Unsize","","Types that can be \"unsized\" to a dynamically-sized type.",null,null],[8,"Copy","","Types whose values can be duplicated simply by copying bits.",null,null],[8,"Sync","","Types for which it is safe to share references between threads.",null,null],[3,"PhantomData","","Zero-sized type used to mark things that \"act like\" they own a `T`.",null,null],[0,"mem","std","Basic functions for dealing with memory.",null,null],[5,"forget","std::mem","Leaks a value: takes ownership and \"forgets\" about the value without running its destructor.",null,null],[5,"size_of","","Returns the size of a type in bytes.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"size_of_val","","Returns the size of the pointed-to value in bytes.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"min_align_of","","Returns the [ABI]-required minimum alignment of a type.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"min_align_of_val","","Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"align_of","","Returns the [ABI]-required minimum alignment of a type.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"align_of_val","","Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.",null,{"inputs":[{"name":"t"}],"output":{"name":"usize"}}],[5,"needs_drop","","Returns whether dropping values of type `T` matters.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"zeroed","","Creates a value whose bytes are all zero.",null,{"inputs":[],"output":{"name":"t"}}],[5,"uninitialized","","Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type `T`, while doing nothing at all.",null,{"inputs":[],"output":{"name":"t"}}],[5,"swap","","Swaps the values at two mutable locations, without deinitializing either one.",null,null],[5,"replace","","Replaces the value at a mutable location with a new one, returning the old value, without deinitializing either one.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"drop","","Disposes of a value.",null,null],[5,"transmute_copy","","Interprets `src` as having type `&U`, and then reads `src` without moving the contained value.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[3,"Discriminant","","Opaque type representing the discriminant of an enum.",null,null],[5,"discriminant","","Returns a value uniquely identifying the enum variant in `v`.",null,{"inputs":[{"name":"t"}],"output":{"name":"discriminant"}}],[19,"ManuallyDrop","","A wrapper to inhibit compiler from automatically calling `T`s destructor.",null,null],[5,"unreachable","","Tells LLVM that this point in the code is not reachable, enabling further optimizations.",null,null],[5,"transmute","","Reinterprets the bits of a value of one type as another type.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[0,"ops","std","Overloadable operators.",null,null],[8,"Shr","std::ops","The right shift operator `>>`.",null,null],[16,"Output","","The resulting type after applying the `>>` operator.",26,null],[10,"shr","","Performs the `>>` operation.",26,null],[4,"GeneratorState","","The result of a generator resumption.",null,null],[13,"Yielded","","The generator suspended with a value.",27,null],[13,"Complete","","The generator completed with a return value.",27,null],[3,"RangeInclusive","","An range bounded inclusively below and above (`start..=end`).",null,null],[12,"start","","The lower bound of the range (inclusive).",28,null],[12,"end","","The upper bound of the range (inclusive).",28,null],[8,"IndexMut","","Used for indexing operations (`container[index]`) in mutable contexts.",null,null],[10,"index_mut","","Performs the mutable indexing (`container[index]`) operation.",29,null],[8,"Placer","","Interface to implementations of  `PLACE <- EXPR`.",null,null],[16,"Place","","`Place` is the intermediate agent guarding the uninitialized state for `Data`.",30,null],[10,"make_place","","Creates a fresh place from `self`.",30,null],[8,"Fn","","The version of the call operator that takes an immutable receiver.",null,null],[10,"call","","Performs the call operation.",31,null],[8,"BitXor","","The bitwise XOR operator `^`.",null,null],[16,"Output","","The resulting type after applying the `^` operator.",32,null],[10,"bitxor","","Performs the `^` operation.",32,null],[8,"DerefMut","","Used for mutable dereferencing operations, like in `*v = 1;`.",null,null],[10,"deref_mut","","Mutably dereferences the value.",33,null],[8,"Try","","A trait for customizing the behavior of the `?` operator.",null,null],[16,"Ok","","The type of this value when viewed as successful.",34,null],[16,"Error","","The type of this value when viewed as failed.",34,null],[10,"into_result","","Applies the \"?\" operator. A return of `Ok(t)` means that the execution should continue normally, and the result of `?` is the value `t`. A return of `Err(e)` means that execution should branch to the innermost enclosing `catch`, or return from the function.",34,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"from_error","","Wrap an error value to construct the composite result. For example, `Result::Err(x)` and `Result::from_error(x)` are equivalent.",34,null],[10,"from_ok","","Wrap an OK value to construct the composite result. For example, `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.",34,null],[8,"Place","","Both `PLACE <- EXPR` and `box EXPR` desugar into expressions that allocate an intermediate \"place\" that holds uninitialized state.  The desugaring evaluates EXPR, and writes the result at the address returned by the `pointer` method of this trait.",null,null],[10,"pointer","","Returns the address where the input value will be written. Note that the data at this address is generally uninitialized, and thus one should use `ptr::write` for initializing it.",35,null],[8,"BitOr","","The bitwise OR operator `|`.",null,null],[16,"Output","","The resulting type after applying the `|` operator.",36,null],[10,"bitor","","Performs the `|` operation.",36,null],[8,"Mul","","The multiplication operator `*`.",null,null],[16,"Output","","The resulting type after applying the `*` operator.",37,null],[10,"mul","","Performs the `*` operation.",37,null],[8,"Index","","Used for indexing operations (`container[index]`) in immutable contexts.",null,null],[16,"Output","","The returned type after indexing.",38,null],[10,"index","","Performs the indexing (`container[index]`) operation.",38,null],[3,"RangeFull","","An unbounded range (`..`).",null,null],[8,"CoerceUnsized","","Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee.",null,null],[8,"RemAssign","","The remainder assignment operator `%=`.",null,null],[10,"rem_assign","","Performs the `%=` operation.",39,null],[8,"Add","","The addition operator `+`.",null,null],[16,"Output","","The resulting type after applying the `+` operator.",40,null],[10,"add","","Performs the `+` operation.",40,null],[8,"BoxPlace","","Specialization of `Place` trait supporting `box EXPR`.",null,null],[10,"make_place","","Creates a globally fresh place.",41,{"inputs":[],"output":{"name":"self"}}],[8,"BitAnd","","The bitwise AND operator `&`.",null,null],[16,"Output","","The resulting type after applying the `&` operator.",42,null],[10,"bitand","","Performs the `&` operation.",42,null],[8,"Generator","","The trait implemented by builtin generator types.",null,null],[16,"Yield","","The type of value this generator yields.",43,null],[16,"Return","","The type of value this generator returns.",43,null],[10,"resume","","Resumes the execution of this generator.",43,{"inputs":[{"name":"self"}],"output":{"name":"generatorstate"}}],[8,"Sub","","The subtraction operator `-`.",null,null],[16,"Output","","The resulting type after applying the `-` operator.",44,null],[10,"sub","","Performs the `-` operation.",44,null],[8,"Neg","","The unary negation operator `-`.",null,null],[16,"Output","","The resulting type after applying the `-` operator.",45,null],[10,"neg","","Performs the unary `-` operation.",45,null],[8,"ShlAssign","","The left shift assignment operator `<<=`.",null,null],[10,"shl_assign","","Performs the `<<=` operation.",46,null],[8,"FnMut","","The version of the call operator that takes a mutable receiver.",null,null],[10,"call_mut","","Performs the call operation.",47,null],[8,"ShrAssign","","The right shift assignment operator `>>=`.",null,null],[10,"shr_assign","","Performs the `>>=` operation.",48,null],[8,"Boxed","","Core trait for the `box EXPR` form.",null,null],[16,"Data","","The kind of data that is stored in this kind of box.",49,null],[16,"Place","","The place that will negotiate the storage of the data.",49,null],[10,"finalize","","Converts filled place into final owning value, shifting deallocation/cleanup responsibilities (if any remain), over to returned instance of `Self` and forgetting `filled`.",49,null],[8,"Shl","","The left shift operator `<<`.",null,null],[16,"Output","","The resulting type after applying the `<<` operator.",50,null],[10,"shl","","Performs the `<<` operation.",50,null],[3,"RangeFrom","","A range only bounded inclusively below (`start..`).",null,null],[12,"start","","The lower bound of the range (inclusive).",51,null],[8,"SubAssign","","The subtraction assignment operator `-=`.",null,null],[10,"sub_assign","","Performs the `-=` operation.",52,null],[8,"DivAssign","","The division assignment operator `/=`.",null,null],[10,"div_assign","","Performs the `/=` operation.",53,null],[8,"Deref","","Used for immutable dereferencing operations, like `*v`.",null,null],[16,"Target","","The resulting type after dereferencing.",54,null],[10,"deref","","Dereferences the value.",54,null],[8,"BitOrAssign","","The bitwise OR assignment operator `|=`.",null,null],[10,"bitor_assign","","Performs the `|=` operation.",55,null],[8,"InPlace","","Specialization of `Place` trait supporting `PLACE <- EXPR`.",null,null],[16,"Owner","","`Owner` is the type of the end value of `PLACE <- EXPR`",56,null],[10,"finalize","","Converts self into the final value, shifting deallocation/cleanup responsibilities (if any remain), over to the returned instance of `Owner` and forgetting self.",56,null],[3,"Range","","A (half-open) range bounded inclusively below and exclusively above (`start..end`).",null,null],[12,"start","","The lower bound of the range (inclusive).",57,null],[12,"end","","The upper bound of the range (exclusive).",57,null],[8,"MulAssign","","The multiplication assignment operator `*=`.",null,null],[10,"mul_assign","","Performs the `*=` operation.",58,null],[8,"AddAssign","","The addition assignment operator `+=`.",null,null],[10,"add_assign","","Performs the `+=` operation.",59,null],[8,"BitAndAssign","","The bitwise AND assignment operator `&=`.",null,null],[10,"bitand_assign","","Performs the `&=` operation.",60,null],[8,"Rem","","The remainder operator `%`.",null,null],[16,"Output","","The resulting type after applying the `%` operator.",61,null],[10,"rem","","Performs the `%` operation.",61,null],[3,"RangeToInclusive","","A range only bounded inclusively above (`..=end`).",null,null],[12,"end","","The upper bound of the range (inclusive)",62,null],[8,"Drop","","Used to run some code when a value goes out of scope. This is sometimes called a 'destructor'.",null,null],[10,"drop","","Executes the destructor for this type.",63,null],[8,"BitXorAssign","","The bitwise XOR assignment operator `^=`.",null,null],[10,"bitxor_assign","","Performs the `^=` operation.",64,null],[8,"Not","","The unary logical negation operator `!`.",null,null],[16,"Output","","The resulting type after applying the `!` operator.",65,null],[10,"not","","Performs the unary `!` operation.",65,null],[8,"FnOnce","","The version of the call operator that takes a by-value receiver.",null,null],[16,"Output","","The returned type after the call operator is used.",66,null],[10,"call_once","","Performs the call operation.",66,null],[3,"RangeTo","","A range only bounded exclusively above (`..end`).",null,null],[12,"end","","The upper bound of the range (exclusive).",67,null],[8,"Div","","The division operator `/`.",null,null],[16,"Output","","The resulting type after applying the `/` operator.",68,null],[10,"div","","Performs the `/` operation.",68,null],[0,"ptr","std","Raw, unsafe pointers, `*const T`, and `*mut T`.",null,null],[5,"drop_in_place","std::ptr","Executes the destructor (if any) of the pointed-to value.",null,null],[5,"null","","Creates a null raw pointer.",null,null],[5,"null_mut","","Creates a null mutable raw pointer.",null,null],[5,"swap","","Swaps the values at two mutable locations of the same type, without deinitializing either.",null,null],[5,"swap_nonoverlapping","","Swaps a sequence of values at two mutable locations of the same type.",null,null],[5,"replace","","Replaces the value at `dest` with `src`, returning the old value, without dropping either.",null,null],[5,"read","","Reads the value from `src` without moving it. This leaves the memory in `src` unchanged.",null,null],[5,"read_unaligned","","Reads the value from `src` without moving it. This leaves the memory in `src` unchanged.",null,null],[5,"write","","Overwrites a memory location with the given value without reading or dropping the old value.",null,null],[5,"write_unaligned","","Overwrites a memory location with the given value without reading or dropping the old value.",null,null],[5,"read_volatile","","Performs a volatile read of the value from `src` without moving it. This leaves the memory in `src` unchanged.",null,null],[5,"write_volatile","","Performs a volatile write of a memory location with the given value without reading or dropping the old value.",null,null],[5,"eq","","Compare raw pointers for equality.",null,null],[3,"Unique","","A wrapper around a raw non-null `*mut T` that indicates that the possessor of this wrapper owns the referent. Useful for building abstractions like `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.",null,null],[3,"Shared","","`*mut T` but non-zero and covariant.",null,null],[5,"write_bytes","","Invokes memset on the specified pointer, setting `count * size_of::<T>()` bytes of memory starting at `dst` to `val`.",null,null],[5,"copy_nonoverlapping","","Copies `count * size_of<T>` bytes from `src` to `dst`. The source and destination may not overlap.",null,null],[5,"copy","","Copies `count * size_of<T>` bytes from `src` to `dst`. The source and destination may overlap.",null,null],[0,"raw","std","Contains struct definitions for the layout of compiler built-in types.",null,null],[3,"TraitObject","std::raw","The representation of a trait object like `&SomeTrait`.",null,null],[12,"data","","",69,null],[12,"vtable","","",69,null],[0,"result","std","Error handling with the `Result` type.",null,null],[4,"Result","std::result","`Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).",null,null],[13,"Ok","","Contains the success value",70,null],[13,"Err","","Contains the error value",70,null],[3,"Iter","","An iterator over a reference to the [`Ok`] variant of a [`Result`].",null,null],[3,"IterMut","","An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].",null,null],[3,"IntoIter","","An iterator over the value in a [`Ok`] variant of a [`Result`].",null,null],[0,"option","std","Optional values.",null,null],[4,"Option","std::option","The `Option` type. See the module level documentation for more.",null,null],[13,"None","","No value",71,null],[13,"Some","","Some value `T`",71,null],[3,"Iter","","An iterator over a reference to the [`Some`] variant of an [`Option`].",null,null],[3,"IterMut","","An iterator over a mutable reference to the [`Some`] variant of an [`Option`].",null,null],[3,"IntoIter","","An iterator over the value in [`Some`] variant of an [`Option`].",null,null],[3,"NoneError","","The error type that results from applying the try operator (`?`) to a `None` value. If you wish to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.",null,null],[0,"isize","std","The pointer-sized signed integer type.",null,null],[17,"MIN","std::isize","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"i8","std","The 8-bit signed integer type.",null,null],[17,"MIN","std::i8","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"i16","std","The 16-bit signed integer type.",null,null],[17,"MIN","std::i16","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"i32","std","The 32-bit signed integer type.",null,null],[17,"MIN","std::i32","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"i64","std","The 64-bit signed integer type.",null,null],[17,"MIN","std::i64","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"i128","std","The 128-bit signed integer type.",null,null],[17,"MIN","std::i128","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"usize","std","The pointer-sized unsigned integer type.",null,null],[17,"MIN","std::usize","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"u8","std","The 8-bit unsigned integer type.",null,null],[17,"MIN","std::u8","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"u16","std","The 16-bit unsigned integer type.",null,null],[17,"MIN","std::u16","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"u32","std","The 32-bit unsigned integer type.",null,null],[17,"MIN","std::u32","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"u64","std","The 64-bit unsigned integer type.",null,null],[17,"MIN","std::u64","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"fmt","std","Utilities for formatting and printing strings.",null,null],[4,"Alignment","std::fmt","Possible alignments returned by `Formatter::align`",null,null],[13,"Left","","Indication that contents should be left-aligned.",72,null],[13,"Right","","Indication that contents should be right-aligned.",72,null],[13,"Center","","Indication that contents should be center-aligned.",72,null],[13,"Unknown","","No alignment was requested.",72,null],[6,"Result","","The type returned by formatter methods.",null,null],[3,"Error","","The error type which is returned from formatting a message into a stream.",null,null],[8,"Write","","A collection of methods that are required to format a message into a stream.",null,null],[10,"write_str","","Writes a slice of bytes into this writer, returning whether the write succeeded.",73,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_char","","Writes a [`char`] into this writer, returning whether the write succeeded.",73,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_fmt","","Glue for usage of the [`write!`] macro with implementors of this trait.",73,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[3,"Formatter","","A struct to represent both where to emit formatting strings to and how they should be formatted. A mutable version of this is passed to all formatting traits.",null,null],[3,"Arguments","","This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.",null,null],[8,"Debug","","`?` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",74,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Display","","Format trait for an empty format, `{}`.",null,null],[10,"fmt","","Formats the value using the given formatter.",75,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Octal","","`o` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",76,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Binary","","`b` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",77,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"LowerHex","","`x` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",78,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"UpperHex","","`X` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",79,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"Pointer","","`p` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",80,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"LowerExp","","`e` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",81,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[8,"UpperExp","","`E` formatting.",null,null],[10,"fmt","","Formats the value using the given formatter.",82,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[5,"write","","The `write` function takes an output stream, and an `Arguments` struct that can be precompiled with the `format_args!` macro.",null,{"inputs":[{"name":"write"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[3,"DebugList","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugSet","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugTuple","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugStruct","","A struct to help with `fmt::Debug` implementations.",null,null],[3,"DebugMap","","A struct to help with `fmt::Debug` implementations.",null,null],[0,"char","std","A character type.",null,null],[3,"ToLowercase","std::char","Returns an iterator that yields the lowercase equivalent of a `char`.",null,null],[3,"ToUppercase","","Returns an iterator that yields the uppercase equivalent of a `char`.",null,null],[3,"DecodeUtf16","","An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.",null,null],[3,"DecodeUtf16Error","","An error that can be returned when decoding UTF-16 code points.",null,null],[5,"decode_utf16","","Create an iterator over the UTF-16 encoded code points in `iter`, returning unpaired surrogates as `Err`s.",null,{"inputs":[{"name":"i"}],"output":{"name":"decodeutf16"}}],[17,"REPLACEMENT_CHARACTER","","`U+FFFD REPLACEMENT CHARACTER` () is used in Unicode to represent a decoding error.",null,null],[5,"from_digit","","Converts a digit in the given radix to a `char`.",null,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"generics":["char"],"name":"option"}}],[3,"ParseCharError","","An error which can be returned when parsing a char.",null,null],[3,"EscapeDefault","","An iterator that yields the literal escape code of a `char`.",null,null],[17,"MAX","","The highest valid code point a `char` can have.",null,null],[5,"from_u32_unchecked","","Converts a `u32` to a `char`, ignoring validity.",null,{"inputs":[{"name":"u32"}],"output":{"name":"char"}}],[3,"CharTryFromError","","The error type returned when a conversion from u32 to char fails.",null,null],[3,"DecodeUtf8","","An iterator over an iterator of bytes of the characters the bytes represent as UTF-8",null,null],[3,"UnicodeVersion","","Represents a Unicode Version.",null,null],[12,"major","","Major version.",83,null],[12,"minor","","Minor version.",83,null],[12,"micro","","Micro (or Update) version.",83,null],[3,"EscapeDebug","","An iterator that yields the literal escape code of a `char`.",null,null],[3,"EscapeUnicode","","Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.",null,null],[5,"from_u32","","Converts a `u32` to a `char`.",null,{"inputs":[{"name":"u32"}],"output":{"generics":["char"],"name":"option"}}],[17,"UNICODE_VERSION","","The version of Unicode that the Unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.",null,null],[5,"decode_utf8","","Decodes an `Iterator` of bytes as UTF-8.",null,{"inputs":[{"name":"i"}],"output":{"name":"decodeutf8"}}],[0,"u128","std","The 128-bit unsigned integer type.",null,null],[17,"MIN","std::u128","The smallest value that can be represented by this integer type.",null,null],[17,"MAX","","The largest value that can be represented by this integer type.",null,null],[0,"prelude","std","The Rust Prelude.",null,null],[0,"v1","std::prelude","The first version of the prelude of The Rust Standard Library.",null,null],[8,"SliceExt","std::prelude::v1","Extension methods for slices.",null,null],[16,"Item","","",84,null],[10,"split_at","","",84,null],[10,"iter","","",84,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[10,"split","","",84,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"split"}}],[10,"rsplit","","",84,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"rsplit"}}],[10,"splitn","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"p"}],"output":{"name":"splitn"}}],[10,"rsplitn","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"p"}],"output":{"name":"rsplitn"}}],[10,"windows","","",84,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"windows"}}],[10,"chunks","","",84,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"chunks"}}],[10,"get","","",84,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[10,"first","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"split_first","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"split_last","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"last","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"get_unchecked","","",84,null],[10,"as_ptr","","",84,null],[10,"binary_search","","",84,null],[10,"binary_search_by","","",84,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"generics":["usize","usize"],"name":"result"}}],[10,"binary_search_by_key","","",84,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"generics":["usize","usize"],"name":"result"}}],[10,"len","","",84,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",84,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"get_mut","","",84,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[10,"iter_mut","","",84,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[10,"first_mut","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"split_first_mut","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"split_last_mut","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"last_mut","","",84,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"split_mut","","",84,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"splitmut"}}],[10,"rsplit_mut","","",84,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"rsplitmut"}}],[10,"splitn_mut","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"p"}],"output":{"name":"splitnmut"}}],[10,"rsplitn_mut","","",84,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"p"}],"output":{"name":"rsplitnmut"}}],[10,"chunks_mut","","",84,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"chunksmut"}}],[10,"swap","","",84,null],[10,"split_at_mut","","",84,null],[10,"reverse","","",84,null],[10,"get_unchecked_mut","","",84,null],[10,"as_mut_ptr","","",84,null],[10,"contains","","",84,null],[10,"starts_with","","",84,null],[10,"ends_with","","",84,null],[10,"rotate","","",84,null],[10,"clone_from_slice","","",84,null],[10,"copy_from_slice","","",84,null],[10,"swap_with_slice","","",84,null],[10,"sort_unstable","","",84,null],[10,"sort_unstable_by","","",84,null],[10,"sort_unstable_by_key","","",84,null],[0,"str","std","Unicode string slices.",null,null],[8,"FromStr","std::str","A trait to abstract the idea of creating a new instance of a type from a string.",null,null],[16,"Err","","The associated error which can be returned from parsing.",85,null],[10,"from_str","","Parses a string `s` to return a value of this type.",85,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[3,"Utf8Error","","Errors which can occur when attempting to interpret a sequence of [`u8`] as a string.",null,null],[3,"Lines","","An iterator over the lines of a string, as string slices.",null,null],[3,"LinesAny","","Created with the method [`lines_any`].",null,null],[3,"Split","","Created with the method [`split`].",null,null],[3,"RSplit","","Created with the method [`rsplit`].",null,null],[3,"SplitN","","Created with the method [`splitn`].",null,null],[3,"RSplitN","","Created with the method [`rsplitn`].",null,null],[3,"SplitTerminator","","Created with the method [`split_terminator`].",null,null],[3,"RSplitTerminator","","Created with the method [`rsplit_terminator`].",null,null],[3,"Matches","","Created with the method [`matches`].",null,null],[3,"RMatches","","Created with the method [`rmatches`].",null,null],[3,"MatchIndices","","Created with the method [`match_indices`].",null,null],[3,"RMatchIndices","","Created with the method [`rmatch_indices`].",null,null],[5,"from_utf8","","Converts a slice of bytes to a string slice.",null,null],[5,"from_utf8_mut","","Converts a mutable slice of bytes to a mutable string slice.",null,null],[3,"Chars","","An iterator over the [`char`]s of a string slice.",null,null],[3,"CharIndices","","An iterator over the [`char`]s of a string slice, and their positions.",null,null],[3,"Bytes","","An iterator over the bytes of a string slice.",null,null],[5,"from_utf8_unchecked","","Converts a slice of bytes to a string slice without checking that the string contains valid UTF-8.",null,null],[5,"from_utf8_unchecked_mut","","Converts a slice of bytes to a string slice without checking that the string contains valid UTF-8; mutable version.",null,null],[3,"ParseBoolError","","An error returned when parsing a `bool` using [`from_str`] fails",null,null],[3,"SplitWhitespace","","An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace.",null,null],[0,"pattern","","The string Pattern API.",null,null],[8,"Pattern","std::str::pattern","A string pattern.",null,null],[16,"Searcher","","Associated searcher for this pattern",86,null],[10,"into_searcher","","Constructs the associated searcher from `self` and the `haystack` to search in.",86,null],[11,"is_contained_in","","Checks whether the pattern matches anywhere in the haystack",86,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"is_prefix_of","","Checks whether the pattern matches at the front of the haystack",86,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"is_suffix_of","","Checks whether the pattern matches at the back of the haystack",86,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[4,"SearchStep","","Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.",null,null],[13,"Match","","Expresses that a match of the pattern has been found at `haystack[a..b]`.",87,null],[13,"Reject","","Expresses that `haystack[a..b]` has been rejected as a possible match of the pattern.",87,null],[13,"Done","","Expresses that every byte of the haystack has been visited, ending the iteration.",87,null],[8,"Searcher","","A searcher for a string pattern.",null,null],[10,"haystack","","Getter for the underlying string to be searched in",88,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"next","","Performs the next search step starting from the front.",88,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","Find the next `Match` result. See `next()`",88,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject","","Find the next `Reject` result. See `next()` and `next_match()`",88,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"ReverseSearcher","","A reverse searcher for a string pattern.",null,null],[10,"next_back","","Performs the next search step starting from the back.",89,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","Find the next `Match` result. See `next_back()`",89,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject_back","","Find the next `Reject` result. See `next_back()`",89,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"DoubleEndedSearcher","","A marker trait to express that a `ReverseSearcher` can be used for a `DoubleEndedIterator` implementation.",null,null],[3,"CharSearcher","","Associated type for `<char as Pattern<'a>>::Searcher`.",null,null],[3,"CharSliceSearcher","","Associated type for `<&[char] as Pattern<'a>>::Searcher`.",null,null],[3,"CharPredicateSearcher","","Associated type for `<F as Pattern<'a>>::Searcher`.",null,null],[3,"StrSearcher","","Associated type for `<&str as Pattern<'a>>::Searcher`.",null,null],[3,"EncodeUtf16","std::str","An iterator of [`u16`] over the string encoded as UTF-16.",null,null],[11,"clone","","",90,{"inputs":[{"name":"self"}],"output":{"name":"encodeutf16"}}],[11,"fmt","","",90,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",90,{"inputs":[{"name":"self"}],"output":{"generics":["u16"],"name":"option"}}],[11,"size_hint","","",90,null],[0,"slice","std","A dynamically-sized view into a contiguous sequence, `[T]`.",null,null],[3,"Chunks","std::slice","An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a time).",null,null],[3,"Windows","","An iterator over overlapping subslices of length `size`.",null,null],[3,"Iter","","Immutable slice iterator",null,null],[3,"IterMut","","Mutable slice iterator.",null,null],[3,"SplitMut","","An iterator over the subslices of the vector which are separated by elements that match `pred`.",null,null],[3,"ChunksMut","","An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size` elements at a time). When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.",null,null],[3,"Split","","An iterator over subslices separated by elements that match a predicate function.",null,null],[3,"SplitN","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",null,null],[3,"RSplitN","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",null,null],[3,"SplitNMut","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.",null,null],[3,"RSplitNMut","","An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.",null,null],[3,"RSplit","","An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.",null,null],[3,"RSplitMut","","An iterator over the subslices of the vector which are separated by elements that match `pred`, starting from the end of the slice.",null,null],[5,"from_raw_parts","","Forms a slice from a pointer and a length.",null,null],[5,"from_raw_parts_mut","","Performs the same functionality as `from_raw_parts`, except that a mutable slice is returned.",null,null],[5,"from_ref","","Converts a reference to T into a slice of length 1 (without copying).",null,null],[5,"from_ref_mut","","Converts a reference to T into a slice of length 1 (without copying).",null,null],[8,"SliceIndex","","A helper trait used for indexing operations.",null,null],[16,"Output","","The output type returned by methods.",91,null],[10,"get","","Returns a shared reference to the output at this location, if in bounds.",91,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[10,"get_mut","","Returns a mutable reference to the output at this location, if in bounds.",91,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"option"}}],[10,"get_unchecked","","Returns a shared reference to the output at this location, without performing any bounds checking.",91,null],[10,"get_unchecked_mut","","Returns a mutable reference to the output at this location, without performing any bounds checking.",91,null],[10,"index","","Returns a shared reference to the output at this location, panicking if out of bounds.",91,null],[10,"index_mut","","Returns a mutable reference to the output at this location, panicking if out of bounds.",91,null],[8,"SliceConcatExt","","An extension trait for concatenating slices",null,null],[16,"Output","","The resulting type after concatenation",92,null],[10,"concat","","Flattens a slice of `T` into a single value `Self::Output`.",92,null],[10,"join","","Flattens a slice of `T` into a single value `Self::Output`, placing a given separator between each.",92,null],[10,"connect","","",92,null],[0,"io","std","Traits, helpers, and type definitions for core I/O functionality.",null,null],[3,"Cursor","std::io","A `Cursor` wraps another type and provides it with a [`Seek`] implementation.",null,null],[3,"Error","","The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and associated traits.",null,null],[3,"Sink","","A writer which will move data into the void.",null,null],[3,"Empty","","A reader which is always at EOF.",null,null],[3,"Repeat","","A reader which yields one byte over and over and over and over and over and...",null,null],[3,"Initializer","","A type used to conditionally initialize buffers passed to `Read` methods.",null,null],[3,"Chain","","Adaptor to chain together two readers.",null,null],[3,"Take","","Reader adaptor which limits the bytes read from an underlying reader.",null,null],[3,"Bytes","","An iterator over `u8` values of a reader.",null,null],[3,"Chars","","An iterator over the `char`s of a reader.",null,null],[4,"ErrorKind","","A list specifying general categories of I/O error.",null,null],[13,"NotFound","","An entity was not found, often a file.",93,null],[13,"PermissionDenied","","The operation lacked the necessary privileges to complete.",93,null],[13,"ConnectionRefused","","The connection was refused by the remote server.",93,null],[13,"ConnectionReset","","The connection was reset by the remote server.",93,null],[13,"ConnectionAborted","","The connection was aborted (terminated) by the remote server.",93,null],[13,"NotConnected","","The network operation failed because it was not connected yet.",93,null],[13,"AddrInUse","","A socket address could not be bound because the address is already in use elsewhere.",93,null],[13,"AddrNotAvailable","","A nonexistent interface was requested or the requested address was not local.",93,null],[13,"BrokenPipe","","The operation failed because a pipe was closed.",93,null],[13,"AlreadyExists","","An entity already exists, often a file.",93,null],[13,"WouldBlock","","The operation needs to block to complete, but the blocking operation was requested to not occur.",93,null],[13,"InvalidInput","","A parameter was incorrect.",93,null],[13,"InvalidData","","Data not valid for the operation were encountered.",93,null],[13,"TimedOut","","The I/O operation's timeout expired, causing it to be canceled.",93,null],[13,"WriteZero","","An error returned when an operation could not be completed because a call to [`write`] returned [`Ok(0)`].",93,null],[13,"Interrupted","","This operation was interrupted.",93,null],[13,"Other","","Any I/O error not part of this list.",93,null],[13,"UnexpectedEof","","An error returned when an operation could not be completed because an \"end of file\" was reached prematurely.",93,null],[4,"SeekFrom","","Enumeration of possible methods to seek within an I/O object.",null,null],[13,"Start","","Set the offset to the provided number of bytes.",94,null],[13,"End","","Set the offset to the size of this object plus the specified number of bytes.",94,null],[13,"Current","","Set the offset to the current position plus the specified number of bytes.",94,null],[4,"CharsError","","An enumeration of possible errors that can be generated from the `Chars` adapter.",null,null],[13,"NotUtf8","","Variant representing that the underlying stream was read successfully but it did not contain valid utf8 data.",95,null],[13,"Other","","Variant representing that an I/O error occurred.",95,null],[5,"copy","","Copies the entire contents of a reader into a writer.",null,{"inputs":[{"name":"r"},{"name":"w"}],"output":{"generics":["u64"],"name":"result"}}],[5,"sink","","Creates an instance of a writer which will successfully consume all data.",null,{"inputs":[],"output":{"name":"sink"}}],[5,"empty","","Constructs a new handle to an empty reader.",null,{"inputs":[],"output":{"name":"empty"}}],[5,"repeat","","Creates an instance of a reader that infinitely repeats one byte.",null,{"inputs":[{"name":"u8"}],"output":{"name":"repeat"}}],[0,"prelude","","The I/O Prelude",null,null],[11,"clone","","",96,{"inputs":[{"name":"self"}],"output":{"name":"cursor"}}],[11,"fmt","","",96,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new cursor wrapping the provided underlying I/O object.",96,{"inputs":[{"name":"t"}],"output":{"name":"cursor"}}],[11,"into_inner","","Consumes this cursor, returning the underlying value.",96,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_ref","","Gets a reference to the underlying value in this cursor.",96,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the underlying value in this cursor.",96,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"position","","Returns the current position of this cursor.",96,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"set_position","","Sets the position of this cursor.",96,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"seek","","",96,{"inputs":[{"name":"self"},{"name":"seekfrom"}],"output":{"generics":["u64"],"name":"result"}}],[11,"read","","",96,null],[11,"read_exact","","",96,null],[11,"initializer","","",96,{"inputs":[{"name":"self"}],"output":{"name":"initializer"}}],[11,"fill_buf","","",96,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"consume","","",96,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"write","","",96,null],[11,"flush","","",96,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",97,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",93,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"fmt","","",93,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",93,null],[11,"cmp","","",93,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"ordering"}}],[11,"eq","","",93,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",93,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"from","","",97,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"new","","Creates a new I/O error from a known kind of error as well as an arbitrary error payload.",97,{"inputs":[{"name":"errorkind"},{"name":"str"}],"output":{"name":"error"}}],[11,"from_raw_os_error","","Creates a new instance of an `Error` from a particular OS error code.",97,{"inputs":[{"name":"i32"}],"output":{"name":"error"}}],[11,"raw_os_error","","Returns the OS error that this error represents (if any).",97,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"option"}}],[11,"kind","","Returns the corresponding `ErrorKind` for this error.",97,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"fmt","","",97,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"read","","",98,null],[11,"initializer","","",98,{"inputs":[{"name":"self"}],"output":{"name":"initializer"}}],[11,"fill_buf","","",98,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"consume","","",98,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",98,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"read","","",99,null],[11,"initializer","","",99,{"inputs":[{"name":"self"}],"output":{"name":"initializer"}}],[11,"fmt","","",99,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"write","","",100,null],[11,"flush","","",100,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",100,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Result","","A specialized `Result` type for I/O operations.",null,null],[8,"Read","","The `Read` trait allows for reading bytes from a source.",null,null],[10,"read","","Pull some bytes from this source into the specified buffer, returning how many bytes were read.",101,null],[11,"initializer","","Determines if this `Read`er can work with buffers of uninitialized memory.",101,{"inputs":[{"name":"self"}],"output":{"name":"initializer"}}],[11,"read_exact","","Read the exact number of bytes required to fill `buf`.",101,null],[11,"by_ref","","Creates a \"by reference\" adaptor for this instance of `Read`.",101,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bytes","","Transforms this `Read` instance to an [`Iterator`] over its bytes.",101,{"inputs":[{"name":"self"}],"output":{"name":"bytes"}}],[11,"chars","","Transforms this `Read` instance to an [`Iterator`] over [`char`]s.",101,{"inputs":[{"name":"self"}],"output":{"name":"chars"}}],[11,"take","","Creates an adaptor which will read at most `limit` bytes from it.",101,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"take"}}],[8,"Write","","A trait for objects which are byte-oriented sinks.",null,null],[10,"write","","Write a buffer into this object, returning how many bytes were written.",102,null],[10,"flush","","Flush this output stream, ensuring that all intermediately buffered contents reach their destination.",102,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"write_all","","Attempts to write an entire buffer into this write.",102,null],[11,"write_fmt","","Writes a formatted string into this writer, returning any error encountered.",102,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"name":"result"}}],[11,"by_ref","","Creates a \"by reference\" adaptor for this instance of `Write`.",102,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[8,"Seek","","The `Seek` trait provides a cursor which can be moved within a stream of bytes.",null,null],[10,"seek","","Seek to an offset, in bytes, in a stream.",103,{"inputs":[{"name":"self"},{"name":"seekfrom"}],"output":{"generics":["u64"],"name":"result"}}],[8,"BufRead","","A `BufRead` is a type of `Read`er which has an internal buffer, allowing it to perform extra ways of reading.",null,null],[10,"fill_buf","","Fills the internal buffer of this object, returning the buffer contents.",104,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"consume","","Tells this buffer that `amt` bytes have been consumed from the buffer, so they should no longer be returned in calls to `read`.",104,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",105,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"zeroing","","Returns a new `Initializer` which will zero out buffers.",105,{"inputs":[],"output":{"name":"initializer"}}],[11,"nop","","Returns a new `Initializer` which will not zero out buffers.",105,{"inputs":[],"output":{"name":"initializer"}}],[11,"should_initialize","","Indicates if a buffer should be initialized.",105,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"initialize","","Initializes a buffer if necessary.",105,null],[11,"eq","","",94,{"inputs":[{"name":"self"},{"name":"seekfrom"}],"output":{"name":"bool"}}],[11,"ne","","",94,{"inputs":[{"name":"self"},{"name":"seekfrom"}],"output":{"name":"bool"}}],[11,"clone","","",94,{"inputs":[{"name":"self"}],"output":{"name":"seekfrom"}}],[11,"fmt","","",94,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into_inner","","Consumes the `Chain`, returning the wrapped readers.",106,null],[11,"get_ref","","Gets references to the underlying readers in this `Chain`.",106,null],[11,"get_mut","","Gets mutable references to the underlying readers in this `Chain`.",106,null],[11,"fmt","","",106,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"read","","",106,null],[11,"initializer","","",106,{"inputs":[{"name":"self"}],"output":{"name":"initializer"}}],[11,"fill_buf","","",106,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"consume","","",106,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",107,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"limit","","Returns the number of bytes that can be read before this instance will return EOF.",107,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"set_limit","","Sets the number of bytes that can be read before this instance will return EOF. This is the same as constructing a new `Take` instance, so the amount of bytes read and the previous limit value don't matter when calling this method.",107,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"into_inner","","Consumes the `Take`, returning the wrapped reader.",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_ref","","Gets a reference to the underlying reader.",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get_mut","","Gets a mutable reference to the underlying reader.",107,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"read","","",107,null],[11,"initializer","","",107,{"inputs":[{"name":"self"}],"output":{"name":"initializer"}}],[11,"fill_buf","","",107,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"consume","","",107,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",108,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",108,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"fmt","","",109,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",95,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",109,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"fmt","","",95,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"sync","std","Useful synchronization primitives.",null,null],[0,"atomic","std::sync","Atomic types",null,null],[5,"spin_loop_hint","std::sync::atomic","Save power or switch hyperthreads in a busy-wait spin-loop.",null,null],[3,"AtomicBool","","A boolean type which can be safely shared between threads.",null,null],[3,"AtomicPtr","","A raw pointer type which can be safely shared between threads.",null,null],[4,"Ordering","","Atomic memory orderings",null,null],[13,"Relaxed","","No ordering constraints, only atomic operations.",110,null],[13,"Release","","When coupled with a store, all previous writes become visible to the other threads that perform a load with [`Acquire`] ordering on the same value.",110,null],[13,"Acquire","","When coupled with a load, all subsequent loads will see data written before a store with [`Release`] ordering on the same value in other threads.",110,null],[13,"AcqRel","","When coupled with a load, uses [`Acquire`] ordering, and with a store [`Release`] ordering.",110,null],[13,"SeqCst","","Like `AcqRel` with the additional guarantee that all threads see all sequentially consistent operations in the same order.",110,null],[17,"ATOMIC_BOOL_INIT","","An [`AtomicBool`] initialized to `false`.",null,null],[3,"AtomicI8","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_I8_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicU8","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_U8_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicI16","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_I16_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicU16","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_U16_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicI32","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_I32_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicU32","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_U32_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicI64","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_I64_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicU64","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_U64_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicIsize","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_ISIZE_INIT","","An atomic integer initialized to `0`.",null,null],[3,"AtomicUsize","","An integer type which can be safely shared between threads.",null,null],[17,"ATOMIC_USIZE_INIT","","An atomic integer initialized to `0`.",null,null],[5,"fence","","An atomic fence.",null,null],[5,"compiler_fence","","A compiler memory fence.",null,null],[14,"try","std","Helper macro for reducing boilerplate code for matching `Result` together with converting downstream errors.",null,null],[14,"writeln","","Write formatted data into a buffer, with a newline appended.",null,null],[14,"write","","Write formatted data into a buffer.",null,null],[14,"unimplemented","","A standardized placeholder for marking unfinished code.",null,null],[14,"unreachable","","A utility macro for indicating unreachable code.",null,null],[14,"debug_assert_ne","","Asserts that two expressions are not equal to each other.",null,null],[14,"debug_assert_eq","","Asserts that two expressions are equal to each other.",null,null],[14,"debug_assert","","Ensure that a boolean expression is `true` at runtime.",null,null],[14,"assert_ne","","Asserts that two expressions are not equal to each other (using [`PartialEq`]).",null,null],[14,"assert_eq","","Asserts that two expressions are equal to each other (using [`PartialEq`]).",null,null],[14,"assert","","Ensure that a boolean expression is `true` at runtime.",null,null],[14,"panic","","Entry point of thread panic, for details, see std::macros",null,null],[11,"is","std::any","Returns `true` if the boxed type is the same as `T`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"downcast_ref","","Returns some reference to the boxed value if it is of type `T`, or `None` if it isn't.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"downcast_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or `None` if it isn't.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is","","Forwards to the method defined on the type `Any`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"downcast_ref","","Forwards to the method defined on the type `Any`.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"downcast_mut","","Forwards to the method defined on the type `Any`.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","std::option","",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"clone","std::any","",111,{"inputs":[{"name":"self"}],"output":{"name":"typeid"}}],[11,"clone","std::slice","",112,{"inputs":[{"name":"self"}],"output":{"name":"windows"}}],[11,"clone","std::str","",113,{"inputs":[{"name":"self"}],"output":{"name":"splitterminator"}}],[11,"clone","","",114,{"inputs":[{"name":"self"}],"output":{"name":"linesany"}}],[11,"clone","std::fmt","",115,{"inputs":[{"name":"self"}],"output":{"name":"arguments"}}],[11,"clone","std::result","",116,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"clone","std::str::pattern","",117,{"inputs":[{"name":"self"}],"output":{"name":"charsearcher"}}],[11,"clone","std::cell","",118,{"inputs":[{"name":"self"}],"output":{"name":"cell"}}],[11,"clone","std::iter","",119,{"inputs":[{"name":"self"}],"output":{"name":"take"}}],[11,"clone","std::str","",120,{"inputs":[{"name":"self"}],"output":{"name":"lines"}}],[11,"clone","","",121,{"inputs":[{"name":"self"}],"output":{"name":"rsplitn"}}],[11,"clone","std::slice","",122,{"inputs":[{"name":"self"}],"output":{"name":"chunks"}}],[11,"clone","std::iter","",123,{"inputs":[{"name":"self"}],"output":{"name":"takewhile"}}],[11,"clone","","",124,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"clone","std::char","",125,{"inputs":[{"name":"self"}],"output":{"name":"chartryfromerror"}}],[11,"clone","std::str::pattern","",87,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"clone","std::convert","",126,{"inputs":[{"name":"self"}],"output":{"name":"infallible"}}],[11,"clone","std::str","",127,{"inputs":[{"name":"self"}],"output":{"name":"charindices"}}],[11,"clone","std::iter","",128,{"inputs":[{"name":"self"}],"output":{"name":"empty"}}],[11,"clone","std::str::pattern","",129,{"inputs":[{"name":"self"}],"output":{"name":"charpredicatesearcher"}}],[11,"clone","std::hash","",130,{"inputs":[{"name":"self"}],"output":{"name":"siphasher13"}}],[11,"clone","std::str::pattern","",131,{"inputs":[{"name":"self"}],"output":{"name":"charslicesearcher"}}],[11,"clone","std::iter","",132,{"inputs":[{"name":"self"}],"output":{"name":"cycle"}}],[11,"clone","std::slice","",133,{"inputs":[{"name":"self"}],"output":{"name":"rsplit"}}],[11,"clone","std::iter","",134,{"inputs":[{"name":"self"}],"output":{"name":"once"}}],[11,"clone","","",135,{"inputs":[{"name":"self"}],"output":{"name":"peekable"}}],[11,"clone","std::str","",136,{"inputs":[{"name":"self"}],"output":{"name":"matchindices"}}],[11,"clone","std::cmp","",3,{"inputs":[{"name":"self"}],"output":{"name":"ordering"}}],[11,"clone","std::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","std::iter","",138,{"inputs":[{"name":"self"}],"output":{"name":"cloned"}}],[11,"clone","std::result","",139,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","std::option","",140,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"clone","","",141,{"inputs":[{"name":"self"}],"output":{"name":"noneerror"}}],[11,"clone","std::iter","",142,{"inputs":[{"name":"self"}],"output":{"name":"fuse"}}],[11,"clone","std::str","",143,{"inputs":[{"name":"self"}],"output":{"name":"parseboolerror"}}],[11,"clone","std::ops","",28,{"inputs":[{"name":"self"}],"output":{"name":"rangeinclusive"}}],[11,"clone","std::iter","",144,{"inputs":[{"name":"self"}],"output":{"name":"flatmap"}}],[11,"clone","std::ops","",145,{"inputs":[{"name":"self"}],"output":{"name":"rangefull"}}],[11,"clone","std::marker","",146,{"inputs":[{"name":"self"}],"output":{"name":"phantomdata"}}],[11,"clone","std::char","",147,{"inputs":[{"name":"self"}],"output":{"name":"parsecharerror"}}],[11,"clone","std::str","",148,{"inputs":[{"name":"self"}],"output":{"name":"chars"}}],[11,"clone","","",149,{"inputs":[{"name":"self"}],"output":{"name":"rsplitterminator"}}],[11,"clone","std::ptr","",150,{"inputs":[{"name":"self"}],"output":{"name":"shared"}}],[11,"clone","std::cell","",151,{"inputs":[{"name":"self"}],"output":{"name":"refcell"}}],[11,"clone","std::str","",152,{"inputs":[{"name":"self"}],"output":{"name":"splitn"}}],[11,"clone","","",153,{"inputs":[{"name":"self"}],"output":{"name":"rmatches"}}],[11,"clone","std::mem","",154,{"inputs":[{"name":"self"}],"output":{"name":"discriminant"}}],[11,"clone","std::iter","",155,{"inputs":[{"name":"self"}],"output":{"name":"enumerate"}}],[11,"clone","","",156,{"inputs":[{"name":"self"}],"output":{"name":"skipwhile"}}],[11,"clone","","",157,{"inputs":[{"name":"self"}],"output":{"name":"stepby"}}],[11,"clone","std::char","",158,{"inputs":[{"name":"self"}],"output":{"name":"decodeutf8"}}],[11,"clone","std::raw","",69,{"inputs":[{"name":"self"}],"output":{"name":"traitobject"}}],[11,"clone","std::iter","",159,{"inputs":[{"name":"self"}],"output":{"name":"skip"}}],[11,"clone","","",160,{"inputs":[{"name":"self"}],"output":{"name":"chain"}}],[11,"clone","std::str","",161,{"inputs":[{"name":"self"}],"output":{"name":"utf8error"}}],[11,"clone","std::hash","",162,{"inputs":[{"name":"self"}],"output":{"name":"siphasher24"}}],[11,"clone","std::str","",163,{"inputs":[{"name":"self"}],"output":{"name":"rsplit"}}],[11,"clone","std::ops","",27,{"inputs":[{"name":"self"}],"output":{"name":"generatorstate"}}],[11,"clone","","",57,{"inputs":[{"name":"self"}],"output":{"name":"range"}}],[11,"clone","std::char","",164,{"inputs":[{"name":"self"}],"output":{"name":"escapedebug"}}],[11,"clone","std::iter","",165,{"inputs":[{"name":"self"}],"output":{"name":"filter"}}],[11,"clone","","",166,{"inputs":[{"name":"self"}],"output":{"name":"filtermap"}}],[11,"clone","std::str::pattern","",167,{"inputs":[{"name":"self"}],"output":{"name":"strsearcher"}}],[11,"clone","std::iter","",168,{"inputs":[{"name":"self"}],"output":{"name":"scan"}}],[11,"clone","std::hash","",169,{"inputs":[{"name":"self"}],"output":{"name":"siphasher"}}],[11,"clone","std::slice","",170,{"inputs":[{"name":"self"}],"output":{"name":"split"}}],[11,"clone","std::iter","",171,{"inputs":[{"name":"self"}],"output":{"name":"inspect"}}],[11,"clone","","",172,{"inputs":[{"name":"self"}],"output":{"name":"zip"}}],[11,"clone","std::ops","",67,{"inputs":[{"name":"self"}],"output":{"name":"rangeto"}}],[11,"clone","std::option","",173,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"clone","std::iter","",174,{"inputs":[{"name":"self"}],"output":{"name":"rev"}}],[11,"clone","std::ptr","",175,{"inputs":[{"name":"self"}],"output":{"name":"unique"}}],[11,"clone","std::char","",176,{"inputs":[{"name":"self"}],"output":{"name":"escapedefault"}}],[11,"clone","std::str","",177,{"inputs":[{"name":"self"}],"output":{"name":"bytes"}}],[11,"clone","std::fmt","",178,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"clone","std::hash","",179,{"inputs":[{"name":"self"}],"output":{"name":"buildhasherdefault"}}],[11,"clone","std::str","",180,{"inputs":[{"name":"self"}],"output":{"name":"rmatchindices"}}],[11,"clone","std::result","",70,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"clone","std::ops","",51,{"inputs":[{"name":"self"}],"output":{"name":"rangefrom"}}],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"rangetoinclusive"}}],[11,"clone","std::mem","",181,{"inputs":[{"name":"self"}],"output":{"name":"manuallydrop"}}],[11,"clone_from","","",181,null],[11,"clone","std::str","",182,{"inputs":[{"name":"self"}],"output":{"name":"split"}}],[11,"clone","std::iter","",183,{"inputs":[{"name":"self"}],"output":{"name":"repeat"}}],[11,"clone","std::sync::atomic","",110,{"inputs":[{"name":"self"}],"output":{"name":"ordering"}}],[11,"clone","std::char","",184,{"inputs":[{"name":"self"}],"output":{"name":"escapeunicode"}}],[11,"clone","std::str","",185,{"inputs":[{"name":"self"}],"output":{"name":"matches"}}],[11,"partial_cmp","std::result","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"le","","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"gt","","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"ge","","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::mem","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"le","","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"gt","","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"ge","","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::marker","",146,{"inputs":[{"name":"self"},{"name":"phantomdata"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","std::option","",141,{"inputs":[{"name":"self"},{"name":"noneerror"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","std::cell","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"name":"bool"}}],[11,"le","","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"name":"bool"}}],[11,"gt","","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"name":"bool"}}],[11,"ge","","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::ops","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"le","","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"gt","","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"ge","","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::convert","",126,{"inputs":[{"name":"self"},{"name":"infallible"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","std::cmp","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"le","","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"ge","","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"gt","","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::cell","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"name":"bool"}}],[11,"le","","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"name":"bool"}}],[11,"gt","","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"name":"bool"}}],[11,"ge","","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::any","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"bool"}}],[11,"le","","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"bool"}}],[11,"gt","","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"bool"}}],[11,"ge","","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::option","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"le","","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"gt","","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"ge","","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"partial_cmp","std::cmp","",3,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"partial_cmp","std::fmt","",178,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"deref","std::mem","",181,null],[11,"deref","std::cell","",186,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref","","",187,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"into_result","std::result","",70,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from_ok","","",70,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[11,"from_error","","",70,{"inputs":[{"name":"e"}],"output":{"name":"result"}}],[11,"into_result","std::option","",71,{"inputs":[{"name":"self"}],"output":{"generics":["noneerror"],"name":"result"}}],[11,"from_ok","","",71,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[11,"from_error","","",71,{"inputs":[{"name":"noneerror"}],"output":{"name":"option"}}],[11,"next_back","std::str","",113,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::iter","",166,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",166,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",166,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","","",144,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",144,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",144,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","std::str","",153,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","","",182,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::iter","",138,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",138,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",138,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"next_back","std::option","",140,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::iter","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","std::slice","",188,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",188,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",188,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","std::option","",189,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::iter","",124,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",124,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"r"}}],[11,"rfold","","",124,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"acc"}}],[11,"next_back","std::slice","",170,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",190,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::str","",180,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::iter","",160,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",160,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",160,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"next_back","std::str","",114,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::option","",173,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::slice","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::result","",116,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::str","",163,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::iter","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",172,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::slice","",133,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::iter","",159,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",159,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next_back","std::slice","",112,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::iter","",183,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::str","",136,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",127,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",149,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::iter","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","std::str","",120,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::iter","",171,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",171,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",171,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","","",174,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",174,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",174,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"rfind","","",174,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"next_back","","",134,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::result","",191,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::slice","",192,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",193,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::result","",139,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::ops","",28,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",57,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","std::str","",148,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next_back","","",185,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next_back","std::iter","",165,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","std::str","",177,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"option"}}],[11,"rfind","","",177,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"next_back","std::iter","",155,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",155,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"rfold","","",155,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next_back","std::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_rfold","","",137,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"rfold","","",137,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"from","std::sync::atomic","",194,{"inputs":[{"name":"i8"}],"output":{"name":"atomici8"}}],[11,"from","","",195,{"inputs":[{"name":"isize"}],"output":{"name":"atomicisize"}}],[11,"from","std::ptr","",150,{"inputs":[{"name":"unique"}],"output":{"name":"shared"}}],[11,"from","std::sync::atomic","",196,{"inputs":[{"name":"i32"}],"output":{"name":"atomici32"}}],[11,"from","std::ptr","",175,{"inputs":[{"name":"t"}],"output":{"name":"unique"}}],[11,"from","std::sync::atomic","",197,{"inputs":[{"name":"usize"}],"output":{"name":"atomicusize"}}],[11,"from","std::ptr","",150,{"inputs":[{"name":"t"}],"output":{"name":"shared"}}],[11,"from","std::option","",71,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[11,"from","std::cell","",151,{"inputs":[{"name":"t"}],"output":{"name":"refcell"}}],[11,"from","std::sync::atomic","",198,{"inputs":[{"name":"u64"}],"output":{"name":"atomicu64"}}],[11,"from","std::cell","",199,{"inputs":[{"name":"t"}],"output":{"name":"unsafecell"}}],[11,"from","std::sync::atomic","",200,{"inputs":[{"name":"i64"}],"output":{"name":"atomici64"}}],[11,"from","","",201,{"inputs":[{"name":"bool"}],"output":{"name":"atomicbool"}}],[11,"from","","",202,{"inputs":[{"name":"u16"}],"output":{"name":"atomicu16"}}],[11,"from","","",203,{"inputs":[{"name":"i16"}],"output":{"name":"atomici16"}}],[11,"from","std::ptr","",150,{"inputs":[{"name":"t"}],"output":{"name":"shared"}}],[11,"from","","",175,{"inputs":[{"name":"t"}],"output":{"name":"unique"}}],[11,"from","std::sync::atomic","",204,{"inputs":[{"name":"u32"}],"output":{"name":"atomicu32"}}],[11,"from","std::cell","",118,{"inputs":[{"name":"t"}],"output":{"name":"cell"}}],[11,"from","std::sync::atomic","",205,null],[11,"from","","",206,{"inputs":[{"name":"u8"}],"output":{"name":"atomicu8"}}],[11,"haystack","std::str::pattern","",117,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",117,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",117,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"haystack","","",167,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",167,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",167,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"haystack","","",131,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",131,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"haystack","","",129,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"next","","",129,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match","","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject","","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_ref","std::slice","",137,null],[11,"from_iter","std::option","Takes each element in the [`Iterator`]: if it is [`None`], no further elements are taken, and the [`None`] is returned. Should no [`None`] occur, a container with the values of each `Option` is returned.",71,{"inputs":[{"name":"i"}],"output":{"name":"option"}}],[11,"from_iter","std::result","Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, a container with the values of each `Result` is returned.",70,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"fmt","std::ptr","",150,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",205,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ptr","",175,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",118,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",113,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::mem","",154,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",136,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::result","",191,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",152,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cmp","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",207,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",57,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",122,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",190,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",120,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",201,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str::pattern","",129,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",114,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::option","",71,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",157,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",182,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",204,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::option","",189,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",171,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::option","",141,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",165,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",143,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",206,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",158,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",156,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",144,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::result","",139,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",110,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",208,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::any","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",176,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",185,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str::pattern","",117,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",164,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",161,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",205,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",174,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",180,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::mem","",181,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",137,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",209,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",148,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",187,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",124,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",194,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",134,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",195,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::any","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::fmt","",72,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",199,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",196,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",200,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",170,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",135,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",153,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str::pattern","",167,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",203,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",166,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",192,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",121,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",168,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",163,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::result","",70,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::convert","",126,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",128,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::marker","",146,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",127,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",183,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",132,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",188,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",155,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",147,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",202,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",198,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",184,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",172,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",142,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",67,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::hash","",130,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",133,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",160,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",149,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",123,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cmp","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",210,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::any","",111,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",145,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",159,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::hash","",162,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",186,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::hash","",169,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::fmt","",115,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",193,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::option","",140,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::ops","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str::pattern","",131,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::result","",116,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::fmt","",178,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",112,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str::pattern","",87,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::option","",173,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",177,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",119,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",125,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",211,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::hash","",179,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::sync::atomic","",197,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::slice","",212,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::iter","",138,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",151,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"next","std::str","",149,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","","",180,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","std::iter","",134,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",134,null],[11,"next","std::char","",176,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"size_hint","","",176,null],[11,"count","","",176,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",176,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["char"],"name":"option"}}],[11,"last","","",176,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next","std::result","",116,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",116,null],[11,"next","std::slice","",133,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",133,null],[11,"next","std::iter","",144,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",144,null],[11,"try_fold","","",144,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",144,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",128,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",128,null],[11,"next","std::slice","",208,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",208,null],[11,"next","std::char","",158,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"next","std::slice","",170,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",170,null],[11,"next","std::option","",189,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",189,null],[11,"next","std::char","",164,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"size_hint","","",164,null],[11,"next","std::iter","",183,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",183,null],[11,"next","std::str","",136,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","std::slice","",192,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",192,null],[11,"next","","",212,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",212,null],[11,"next","std::str","",163,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::slice","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",122,null],[11,"count","","",122,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",122,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",122,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","std::str","",121,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::slice","",190,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",190,null],[11,"count","","",190,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",190,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",190,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","std::ops","",51,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",51,null],[11,"nth","","",51,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","std::iter","",156,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",156,null],[11,"try_fold","","",156,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",156,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::str","",177,{"inputs":[{"name":"self"}],"output":{"generics":["u8"],"name":"option"}}],[11,"size_hint","","",177,null],[11,"count","","",177,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",177,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",177,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"all","","",177,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"any","","",177,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"bool"}}],[11,"find","","",177,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"position","","",177,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"rposition","","",177,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"next","std::iter","",165,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",165,null],[11,"count","","",165,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"try_fold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",165,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",142,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",142,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",142,null],[11,"try_fold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",159,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",159,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"count","","",159,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",159,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",159,null],[11,"try_fold","","",159,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",159,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::str","",185,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",137,null],[11,"count","","",137,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",137,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",137,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_fold","","",137,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",137,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::option","",140,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",140,null],[11,"next","std::iter","",124,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",124,null],[11,"try_fold","","",124,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"r"}}],[11,"fold","","",124,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"g"}],"output":{"name":"acc"}}],[11,"next","std::slice","",112,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",112,null],[11,"count","","",112,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",112,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",112,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","std::iter","",138,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",138,null],[11,"try_fold","","",138,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",138,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"next","","",123,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",123,null],[11,"try_fold","","",123,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next","std::str","",127,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",127,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",127,null],[11,"last","","",127,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","std::iter","",160,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",160,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"try_fold","","",160,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",160,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"nth","","",160,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"find","","",160,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"last","","",160,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",160,null],[11,"next","","",174,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",174,null],[11,"try_fold","","",174,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",174,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"f"}],"output":{"name":"acc"}}],[11,"find","","",174,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"rposition","","",174,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"generics":["usize"],"name":"option"}}],[11,"next","","",132,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",132,null],[11,"next","std::str","",120,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"size_hint","","",120,null],[11,"next","std::iter","",171,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",171,null],[11,"try_fold","","",171,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",171,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::result","",139,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",139,null],[11,"next","std::str","",182,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::option","",173,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",173,null],[11,"next","std::str","",148,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"count","","",148,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",148,null],[11,"last","","",148,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next","","",114,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"size_hint","","",114,null],[11,"next","std::ops","",57,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",57,null],[11,"nth","","",57,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","std::slice","",210,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",210,null],[11,"next","std::result","",191,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",191,null],[11,"next","std::iter","",119,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",119,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"size_hint","","",119,null],[11,"try_fold","","",119,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next","std::str","",153,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::iter","Overflow Behavior",155,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",155,null],[11,"nth","","",155,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"count","","",155,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"try_fold","","",155,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",155,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",166,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",166,null],[11,"try_fold","","",166,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",166,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"nth","","",142,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",142,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",142,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size_hint","","",142,null],[11,"try_fold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"fold","","",142,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::slice","",193,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",193,null],[11,"next","std::iter","",172,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",172,null],[11,"next","","",168,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",168,null],[11,"try_fold","","",168,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"r"}}],[11,"next","std::slice","",209,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",209,null],[11,"next","std::str","",152,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::ops","",28,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",28,null],[11,"nth","","",28,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"next","std::slice","",188,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",188,null],[11,"count","","",188,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",188,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",188,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_fold","","",188,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",188,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::str","",113,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::iter","",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"count","","",135,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"nth","","",135,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"last","","",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",135,null],[11,"try_fold","","",135,{"inputs":[{"name":"self"},{"name":"b"},{"name":"f"}],"output":{"name":"r"}}],[11,"fold","","",135,{"inputs":[{"name":"self"},{"name":"acc"},{"name":"fold"}],"output":{"name":"acc"}}],[11,"next","std::char","",184,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"size_hint","","",184,null],[11,"count","","",184,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"last","","",184,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next","std::iter","",157,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"size_hint","","",157,null],[11,"sum","std::result","Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, the sum of all elements is returned.",70,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"is_empty","std::slice","",188,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","std::iter","",134,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","","",171,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",171,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",142,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",142,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_empty","std::slice","",137,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","std::char","",184,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","std::iter","",128,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","std::str","",177,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",177,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","std::iter","",124,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",124,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",138,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",138,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","std::char","",176,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"len","std::iter","",174,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",174,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","",155,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",155,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"write_str","std::fmt","",213,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_char","","",213,{"inputs":[{"name":"self"},{"name":"char"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_fmt","","",213,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[11,"get","std::ops","",28,null],[11,"get_mut","","",28,null],[11,"get_unchecked","","",28,null],[11,"get_unchecked_mut","","",28,null],[11,"index","","",28,null],[11,"index_mut","","",28,null],[11,"get","","",145,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",145,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",145,null],[11,"get_unchecked_mut","","",145,null],[11,"index","","",145,null],[11,"index_mut","","",145,null],[11,"get","","",28,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",28,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",28,null],[11,"get_unchecked_mut","","",28,null],[11,"index","","",28,null],[11,"index_mut","","",28,null],[11,"get","","",57,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",57,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",57,null],[11,"get_unchecked_mut","","",57,null],[11,"index","","",57,null],[11,"index_mut","","",57,null],[11,"get","","",67,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",67,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",67,null],[11,"get_unchecked_mut","","",67,null],[11,"index","","",67,null],[11,"index_mut","","",67,null],[11,"get","","",57,null],[11,"get_mut","","",57,null],[11,"get_unchecked","","",57,null],[11,"get_unchecked_mut","","",57,null],[11,"index","","",57,null],[11,"index_mut","","",57,null],[11,"get","","",145,null],[11,"get_mut","","",145,null],[11,"get_unchecked","","",145,null],[11,"get_unchecked_mut","","",145,null],[11,"index","","",145,null],[11,"index_mut","","",145,null],[11,"get","","",67,null],[11,"get_mut","","",67,null],[11,"get_unchecked","","",67,null],[11,"get_unchecked_mut","","",67,null],[11,"index","","",67,null],[11,"index_mut","","",67,null],[11,"get","","",51,null],[11,"get_mut","","",51,null],[11,"get_unchecked","","",51,null],[11,"get_unchecked_mut","","",51,null],[11,"index","","",51,null],[11,"index_mut","","",51,null],[11,"get","","",62,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",62,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",62,null],[11,"get_unchecked_mut","","",62,null],[11,"index","","",62,null],[11,"index_mut","","",62,null],[11,"get","","",51,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_mut","","",51,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"get_unchecked","","",51,null],[11,"get_unchecked_mut","","",51,null],[11,"index","","",51,null],[11,"index_mut","","",51,null],[11,"get","","",62,null],[11,"get_mut","","",62,null],[11,"get_unchecked","","",62,null],[11,"get_unchecked_mut","","",62,null],[11,"index","","",62,null],[11,"index_mut","","",62,null],[11,"hash","std::cmp","",3,null],[11,"hash","std::ops","",57,null],[11,"hash","std::option","",141,null],[11,"hash","std::convert","",126,null],[11,"hash","std::mem","",181,null],[11,"hash","std::option","",71,null],[11,"hash","std::fmt","",178,null],[11,"hash","std::ops","",28,null],[11,"hash","std::marker","",146,null],[11,"hash","std::any","",111,null],[11,"hash","std::result","",70,null],[11,"hash","std::mem","",154,null],[11,"hash","std::ops","",145,null],[11,"hash","","",51,null],[11,"hash","","",62,null],[11,"hash","","",27,null],[11,"hash","","",67,null],[11,"into_iter","std::option","Returns a consuming iterator over the possibly contained value.",71,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"into_iter","std::result","Returns a consuming iterator over the possibly contained value.",70,{"inputs":[{"name":"self"}],"output":{"name":"intoiter"}}],[11,"deref_mut","std::cell","",187,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","std::mem","",181,null],[11,"cmp","std::ops","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"ordering"}}],[11,"cmp","std::convert","",126,{"inputs":[{"name":"self"},{"name":"infallible"}],"output":{"name":"ordering"}}],[11,"cmp","std::option","",141,{"inputs":[{"name":"self"},{"name":"noneerror"}],"output":{"name":"ordering"}}],[11,"cmp","std::cmp","",3,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"ordering"}}],[11,"cmp","std::option","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"ordering"}}],[11,"cmp","std::cell","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"name":"ordering"}}],[11,"cmp","std::any","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"ordering"}}],[11,"cmp","std::result","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"ordering"}}],[11,"cmp","std::marker","",146,{"inputs":[{"name":"self"},{"name":"phantomdata"}],"output":{"name":"ordering"}}],[11,"cmp","std::cell","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"name":"ordering"}}],[11,"cmp","std::mem","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"ordering"}}],[11,"cmp","std::cmp","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"ordering"}}],[11,"cmp","std::fmt","",178,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"ordering"}}],[11,"fmt","std::str","",143,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",211,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::fmt","",178,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::convert","",126,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",207,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",186,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",164,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",184,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::fmt","",115,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",176,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::cell","",187,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",147,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",125,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",161,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"product","std::result","Takes each element in the `Iterator`: if it is an `Err`, no further elements are taken, and the `Err` is returned. Should no `Err` occur, the product of all elements is returned.",70,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"eq","std::ops","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"generatorstate"}],"output":{"name":"bool"}}],[11,"eq","std::any","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"bool"}}],[11,"ne","","",111,{"inputs":[{"name":"self"},{"name":"typeid"}],"output":{"name":"bool"}}],[11,"eq","std::ops","",62,{"inputs":[{"name":"self"},{"name":"rangetoinclusive"}],"output":{"name":"bool"}}],[11,"ne","","",62,{"inputs":[{"name":"self"},{"name":"rangetoinclusive"}],"output":{"name":"bool"}}],[11,"eq","std::str","",143,{"inputs":[{"name":"self"},{"name":"parseboolerror"}],"output":{"name":"bool"}}],[11,"ne","","",143,{"inputs":[{"name":"self"},{"name":"parseboolerror"}],"output":{"name":"bool"}}],[11,"eq","std::fmt","",178,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"eq","std::marker","",146,{"inputs":[{"name":"self"},{"name":"phantomdata"}],"output":{"name":"bool"}}],[11,"eq","std::mem","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"ne","","",181,{"inputs":[{"name":"self"},{"name":"manuallydrop"}],"output":{"name":"bool"}}],[11,"eq","std::str::pattern","",87,{"inputs":[{"name":"self"},{"name":"searchstep"}],"output":{"name":"bool"}}],[11,"ne","","",87,{"inputs":[{"name":"self"},{"name":"searchstep"}],"output":{"name":"bool"}}],[11,"eq","std::ops","",51,{"inputs":[{"name":"self"},{"name":"rangefrom"}],"output":{"name":"bool"}}],[11,"ne","","",51,{"inputs":[{"name":"self"},{"name":"rangefrom"}],"output":{"name":"bool"}}],[11,"eq","std::str","",161,{"inputs":[{"name":"self"},{"name":"utf8error"}],"output":{"name":"bool"}}],[11,"ne","","",161,{"inputs":[{"name":"self"},{"name":"utf8error"}],"output":{"name":"bool"}}],[11,"eq","std::result","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"ne","","",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"bool"}}],[11,"eq","std::option","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"ne","","",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"bool"}}],[11,"eq","std::mem","",154,{"inputs":[{"name":"self"},{"name":"discriminant"}],"output":{"name":"bool"}}],[11,"eq","std::ops","",28,{"inputs":[{"name":"self"},{"name":"rangeinclusive"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"self"},{"name":"rangeinclusive"}],"output":{"name":"bool"}}],[11,"eq","std::convert","",126,{"inputs":[{"name":"self"},{"name":"infallible"}],"output":{"name":"bool"}}],[11,"eq","std::ops","",145,{"inputs":[{"name":"self"},{"name":"rangefull"}],"output":{"name":"bool"}}],[11,"eq","","",57,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"ne","","",57,{"inputs":[{"name":"self"},{"name":"range"}],"output":{"name":"bool"}}],[11,"eq","std::char","",125,{"inputs":[{"name":"self"},{"name":"chartryfromerror"}],"output":{"name":"bool"}}],[11,"ne","","",125,{"inputs":[{"name":"self"},{"name":"chartryfromerror"}],"output":{"name":"bool"}}],[11,"eq","std::cell","",118,{"inputs":[{"name":"self"},{"name":"cell"}],"output":{"name":"bool"}}],[11,"eq","std::cmp","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"reverse"}],"output":{"name":"bool"}}],[11,"eq","std::ops","",67,{"inputs":[{"name":"self"},{"name":"rangeto"}],"output":{"name":"bool"}}],[11,"ne","","",67,{"inputs":[{"name":"self"},{"name":"rangeto"}],"output":{"name":"bool"}}],[11,"eq","std::cell","",151,{"inputs":[{"name":"self"},{"name":"refcell"}],"output":{"name":"bool"}}],[11,"eq","std::option","",141,{"inputs":[{"name":"self"},{"name":"noneerror"}],"output":{"name":"bool"}}],[11,"eq","std::cmp","",3,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"build_hasher","std::hash","",179,{"inputs":[{"name":"self"}],"output":{"name":"h"}}],[11,"write","","",130,null],[11,"finish","","",130,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"write","","",162,null],[11,"finish","","",162,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"write","","",169,null],[11,"finish","","",169,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"next_back","std::str::pattern","",129,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject_back","","",129,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",131,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_reject_back","","",131,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",117,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",117,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next_back","","",167,{"inputs":[{"name":"self"}],"output":{"name":"searchstep"}}],[11,"next_match_back","","",167,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"default","std::sync::atomic","",194,{"inputs":[],"output":{"name":"atomici8"}}],[11,"default","","Creates an `AtomicBool` initialized to `false`.",201,{"inputs":[],"output":{"name":"atomicbool"}}],[11,"default","","",196,{"inputs":[],"output":{"name":"atomici32"}}],[11,"default","std::hash","",130,{"inputs":[],"output":{"name":"siphasher13"}}],[11,"default","std::sync::atomic","",200,{"inputs":[],"output":{"name":"atomici64"}}],[11,"default","","",198,{"inputs":[],"output":{"name":"atomicu64"}}],[11,"default","std::hash","",179,{"inputs":[],"output":{"name":"buildhasherdefault"}}],[11,"default","","",162,{"inputs":[],"output":{"name":"siphasher24"}}],[11,"default","std::cell","Creates a `Cell<T>`, with the `Default` value for T.",118,{"inputs":[],"output":{"name":"cell"}}],[11,"default","std::sync::atomic","",206,{"inputs":[],"output":{"name":"atomicu8"}}],[11,"default","","",197,{"inputs":[],"output":{"name":"atomicusize"}}],[11,"default","std::cell","Creates an `UnsafeCell`, with the `Default` value for T.",199,{"inputs":[],"output":{"name":"unsafecell"}}],[11,"default","std::hash","",169,{"inputs":[],"output":{"name":"siphasher"}}],[11,"default","std::sync::atomic","",204,{"inputs":[],"output":{"name":"atomicu32"}}],[11,"default","","",195,{"inputs":[],"output":{"name":"atomicisize"}}],[11,"default","","Creates a null `AtomicPtr<T>`.",205,{"inputs":[],"output":{"name":"atomicptr"}}],[11,"default","std::fmt","",178,{"inputs":[],"output":{"name":"error"}}],[11,"default","std::marker","",146,{"inputs":[],"output":{"name":"phantomdata"}}],[11,"default","std::cell","Creates a `RefCell<T>`, with the `Default` value for T.",151,{"inputs":[],"output":{"name":"refcell"}}],[11,"default","std::mem","",181,{"inputs":[],"output":{"name":"manuallydrop"}}],[11,"default","std::option","Returns [`None`].",71,{"inputs":[],"output":{"name":"option"}}],[11,"default","std::sync::atomic","",203,{"inputs":[],"output":{"name":"atomici16"}}],[11,"default","std::iter","",128,{"inputs":[],"output":{"name":"empty"}}],[11,"default","std::sync::atomic","",202,{"inputs":[],"output":{"name":"atomicu16"}}],[11,"next_back","std::str","",214,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"clone","std::char","",215,{"inputs":[{"name":"self"}],"output":{"name":"decodeutf16error"}}],[11,"clone","std::str","",214,{"inputs":[{"name":"self"}],"output":{"name":"splitwhitespace"}}],[11,"clone","std::char","",216,{"inputs":[{"name":"self"}],"output":{"name":"decodeutf16"}}],[11,"clone","","",83,{"inputs":[{"name":"self"}],"output":{"name":"unicodeversion"}}],[11,"partial_cmp","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"bool"}}],[11,"le","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"bool"}}],[11,"gt","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"bool"}}],[11,"ge","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"bool"}}],[11,"next","","",216,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"option"}}],[11,"size_hint","","",216,null],[11,"next","","",217,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"next","std::str","",214,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"next","std::char","",218,{"inputs":[{"name":"self"}],"output":{"generics":["char"],"name":"option"}}],[11,"fmt","","",215,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",218,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",217,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"cmp","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"ordering"}}],[11,"eq","","",215,{"inputs":[{"name":"self"},{"name":"decodeutf16error"}],"output":{"name":"bool"}}],[11,"ne","","",215,{"inputs":[{"name":"self"},{"name":"decodeutf16error"}],"output":{"name":"bool"}}],[11,"eq","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"bool"}}],[11,"ne","","",83,{"inputs":[{"name":"self"},{"name":"unicodeversion"}],"output":{"name":"bool"}}],[11,"fmt","","",217,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",215,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",83,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",218,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::str","",214,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","std::char","",216,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"of","std::any","Returns the `TypeId` of the type this generic function has been instantiated with.",111,{"inputs":[],"output":{"name":"typeid"}}],[11,"get","std::cell","Returns a copy of the contained value.",118,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"new","","Creates a new `Cell` containing the given value.",118,{"inputs":[{"name":"t"}],"output":{"name":"cell"}}],[11,"as_ptr","","Returns a raw pointer to the underlying data in this cell.",118,null],[11,"get_mut","","Returns a mutable reference to the underlying data.",118,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"set","","Sets the contained value.",118,null],[11,"swap","","Swaps the values of two Cells. Difference with `std::mem::swap` is that this function doesn't require `&mut` reference.",118,null],[11,"replace","","Replaces the contained value, and returns it.",118,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"into_inner","","Unwraps the value.",118,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"take","","Takes the value of the cell, leaving `Default::default()` in its place.",118,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"new","","Creates a new `RefCell` containing `value`.",151,{"inputs":[{"name":"t"}],"output":{"name":"refcell"}}],[11,"into_inner","","Consumes the `RefCell`, returning the wrapped value.",151,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"replace","","Replaces the wrapped value with a new one, returning the old value, without deinitializing either one.",151,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"replace_with","","Replaces the wrapped value with a new one computed from `f`, returning the old value, without deinitializing either one.",151,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"swap","","Swaps the wrapped value of `self` with the wrapped value of `other`, without deinitializing either one.",151,null],[11,"borrow","","Immutably borrows the wrapped value.",151,{"inputs":[{"name":"self"}],"output":{"name":"ref"}}],[11,"try_borrow","","Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.",151,{"inputs":[{"name":"self"}],"output":{"generics":["ref","borrowerror"],"name":"result"}}],[11,"borrow_mut","","Mutably borrows the wrapped value.",151,{"inputs":[{"name":"self"}],"output":{"name":"refmut"}}],[11,"try_borrow_mut","","Mutably borrows the wrapped value, returning an error if the value is currently borrowed.",151,{"inputs":[{"name":"self"}],"output":{"generics":["refmut","borrowmuterror"],"name":"result"}}],[11,"as_ptr","","Returns a raw pointer to the underlying data in this cell.",151,null],[11,"get_mut","","Returns a mutable reference to the underlying data.",151,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"clone","","Copies a `Ref`.",186,{"inputs":[{"name":"ref"}],"output":{"name":"ref"}}],[11,"map","","Make a new `Ref` for a component of the borrowed data.",186,{"inputs":[{"name":"ref"},{"name":"f"}],"output":{"name":"ref"}}],[11,"map","","Make a new `RefMut` for a component of the borrowed data, e.g. an enum variant.",187,{"inputs":[{"name":"refmut"},{"name":"f"}],"output":{"name":"refmut"}}],[11,"new","","Constructs a new instance of `UnsafeCell` which will wrap the specified value.",199,{"inputs":[{"name":"t"}],"output":{"name":"unsafecell"}}],[11,"into_inner","","Unwraps the value.",199,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"get","","Gets a mutable pointer to the wrapped value.",199,null],[11,"reverse","std::cmp","Reverses the `Ordering`.",3,{"inputs":[{"name":"self"}],"output":{"name":"ordering"}}],[11,"then","","Chains two orderings.",3,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"ordering"}}],[11,"then_with","","Chains the ordering with the given function.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"ordering"}}],[11,"new","std::hash","Creates a new `SipHasher` with the two initial keys set to 0.",169,{"inputs":[],"output":{"name":"siphasher"}}],[11,"new_with_keys","","Creates a `SipHasher` that is keyed off the provided keys.",169,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"siphasher"}}],[11,"new","","Creates a new `SipHasher24` with the two initial keys set to 0.",162,{"inputs":[],"output":{"name":"siphasher24"}}],[11,"new_with_keys","","Creates a `SipHasher24` that is keyed off the provided keys.",162,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"siphasher24"}}],[11,"new","","Creates a new `SipHasher13` with the two initial keys set to 0.",130,{"inputs":[],"output":{"name":"siphasher13"}}],[11,"new_with_keys","","Creates a `SipHasher13` that is keyed off the provided keys.",130,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"siphasher13"}}],[11,"peek","std::iter","Returns a reference to the next() value without advancing the iterator.",135,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","std::mem","Wrap a value to be manually dropped.",181,{"inputs":[{"name":"t"}],"output":{"name":"manuallydrop"}}],[11,"into_inner","","Extract the value from the ManuallyDrop container.",181,{"inputs":[{"name":"manuallydrop"}],"output":{"name":"t"}}],[11,"drop","","Manually drops the contained value.",181,null],[11,"contains","std::ops","Returns `true` if `item` is contained in the range.",28,{"inputs":[{"name":"self"},{"name":"idx"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",51,{"inputs":[{"name":"self"},{"name":"idx"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",57,{"inputs":[{"name":"self"},{"name":"idx"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",62,{"inputs":[{"name":"self"},{"name":"idx"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` if `item` is contained in the range.",67,{"inputs":[{"name":"self"},{"name":"idx"}],"output":{"name":"bool"}}],[11,"empty","std::ptr","Creates a new `Unique` that is dangling, but well-aligned.",175,{"inputs":[],"output":{"name":"unique"}}],[11,"new_unchecked","","Creates a new `Unique`.",175,null],[11,"new","","Creates a new `Unique` if `ptr` is non-null.",175,null],[11,"as_ptr","","Acquires the underlying `*mut` pointer.",175,null],[11,"as_ref","","Dereferences the content.",175,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_mut","","Mutably dereferences the content.",175,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"empty","","Creates a new `Shared` that is dangling, but well-aligned.",150,{"inputs":[],"output":{"name":"shared"}}],[11,"new_unchecked","","Creates a new `Shared`.",150,null],[11,"new","","Creates a new `Shared` if `ptr` is non-null.",150,null],[11,"as_ptr","","Acquires the underlying `*mut` pointer.",150,null],[11,"as_ref","","Dereferences the content.",150,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_mut","","Mutably dereferences the content.",150,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"as_mut_ptr","","Acquires the underlying pointer as a `*mut` pointer.",150,null],[11,"is_ok","std::result","Returns `true` if the result is [`Ok`].",70,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_err","","Returns `true` if the result is [`Err`].",70,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"ok","","Converts from `Result<T, E>` to [`Option<T>`].",70,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"err","","Converts from `Result<T, E>` to [`Option<E>`].",70,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_ref","","Converts from `Result<T, E>` to `Result<&T, &E>`.",70,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"as_mut","","Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.",70,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained [`Ok`] value, leaving an [`Err`] value untouched.",70,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained [`Err`] value, leaving an [`Ok`] value untouched.",70,{"inputs":[{"name":"self"},{"name":"o"}],"output":{"name":"result"}}],[11,"iter","","Returns an iterator over the possibly contained value.",70,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",70,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"and","","Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"result"}}],[11,"and_then","","Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.",70,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"or","","Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.",70,{"inputs":[{"name":"self"},{"name":"result"}],"output":{"name":"result"}}],[11,"or_else","","Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.",70,{"inputs":[{"name":"self"},{"name":"o"}],"output":{"name":"result"}}],[11,"unwrap_or","","Unwraps a result, yielding the content of an [`Ok`]. Else, it returns `optb`.",70,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"unwrap_or_else","","Unwraps a result, yielding the content of an [`Ok`]. If the value is an [`Err`] then it calls `op` with its value.",70,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"unwrap","","Unwraps a result, yielding the content of an [`Ok`].",70,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"expect","","Unwraps a result, yielding the content of an [`Ok`].",70,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap_err","","Unwraps a result, yielding the content of an [`Err`].",70,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"expect_err","","Unwraps a result, yielding the content of an [`Err`].",70,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"e"}}],[11,"unwrap_or_default","","Returns the contained value or a default",70,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"is_some","std::option","Returns `true` if the option is a [`Some`] value.",71,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_none","","Returns `true` if the option is a [`None`] value.",71,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_ref","","Converts from `Option<T>` to `Option<&T>`.",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_mut","","Converts from `Option<T>` to `Option<&mut T>`.",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"expect","","Unwraps an option, yielding the content of a [`Some`].",71,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap","","Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].",71,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"unwrap_or","","Returns the contained value or a default.",71,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",71,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.",71,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_or","","Applies a function to the contained value (if any), or returns a [`default`][] (if not).",71,{"inputs":[{"name":"self"},{"name":"u"},{"name":"f"}],"output":{"name":"u"}}],[11,"map_or_else","","Applies a function to the contained value (if any), or computes a [`default`][] (if not).",71,{"inputs":[{"name":"self"},{"name":"d"},{"name":"f"}],"output":{"name":"u"}}],[11,"ok_or","","Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err)`].",71,{"inputs":[{"name":"self"},{"name":"e"}],"output":{"name":"result"}}],[11,"ok_or_else","","Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to [`Ok(v)`] and [`None`] to [`Err(err())`].",71,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"iter","","Returns an iterator over the possibly contained value.",71,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",71,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"and","","Returns [`None`] if the option is [`None`], otherwise returns `optb`.",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"option"}}],[11,"and_then","","Returns [`None`] if the option is [`None`], otherwise calls `f` with the wrapped value and returns the result.",71,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"filter","","Returns `None` if the option is `None`, otherwise calls `predicate` with the wrapped value and returns:",71,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"option"}}],[11,"or","","Returns the option if it contains a value, otherwise returns `optb`.",71,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"option"}}],[11,"or_else","","Returns the option if it contains a value, otherwise calls `f` and returns the result.",71,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"option"}}],[11,"get_or_insert","","Inserts `v` into the option if it is [`None`], then returns a mutable reference to the contained value.",71,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"t"}}],[11,"get_or_insert_with","","Inserts a value computed from `f` into the option if it is [`None`], then returns a mutable reference to the contained value.",71,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[11,"take","","Takes the value out of the option, leaving a [`None`] in its place.",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"cloned","","Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the option.",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"cloned","","Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the option.",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"unwrap_or_default","","Returns the contained value or a default",71,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"pad_integral","std::fmt","Performs the correct padding for an integer which has already been emitted into a str. The str should not contain the sign for the integer, that will be added by this method.",213,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"str"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"pad","","This function takes a string slice and emits it to the internal buffer after applying the relevant formatting flags specified. The flags recognized for generic strings are:",213,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_str","","Writes some data to the underlying buffer contained within this formatter.",213,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_fmt","","Writes some formatted information into this instance",213,{"inputs":[{"name":"self"},{"name":"arguments"}],"output":{"generics":["error"],"name":"result"}}],[11,"flags","","Flags for formatting",213,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"fill","","Character used as 'fill' whenever there is alignment",213,{"inputs":[{"name":"self"}],"output":{"name":"char"}}],[11,"align","","Flag indicating what form of alignment was requested",213,{"inputs":[{"name":"self"}],"output":{"name":"alignment"}}],[11,"width","","Optionally specified integer width that the output should be",213,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"precision","","Optionally specified precision for numeric types",213,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"sign_plus","","Determines if the `+` flag was specified.",213,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sign_minus","","Determines if the `-` flag was specified.",213,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"alternate","","Determines if the `#` flag was specified.",213,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"sign_aware_zero_pad","","Determines if the `0` flag was specified.",213,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"debug_struct","","Creates a [`DebugStruct`] builder designed to assist with creation of [`fmt::Debug`] implementations for structs.",213,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"debugstruct"}}],[11,"debug_tuple","","Creates a `DebugTuple` builder designed to assist with creation of `fmt::Debug` implementations for tuple structs.",213,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"debugtuple"}}],[11,"debug_list","","Creates a `DebugList` builder designed to assist with creation of `fmt::Debug` implementations for list-like structures.",213,{"inputs":[{"name":"self"}],"output":{"name":"debuglist"}}],[11,"debug_set","","Creates a `DebugSet` builder designed to assist with creation of `fmt::Debug` implementations for set-like structures.",213,{"inputs":[{"name":"self"}],"output":{"name":"debugset"}}],[11,"debug_map","","Creates a `DebugMap` builder designed to assist with creation of `fmt::Debug` implementations for map-like structures.",213,{"inputs":[{"name":"self"}],"output":{"name":"debugmap"}}],[11,"entry","","Adds a new entry to the list output.",219,{"inputs":[{"name":"self"},{"name":"debug"}],"output":{"name":"debuglist"}}],[11,"entries","","Adds the contents of an iterator of entries to the list output.",219,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"debuglist"}}],[11,"finish","","Finishes output and returns any error encountered.",219,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"entry","","Adds a new entry to the set output.",220,{"inputs":[{"name":"self"},{"name":"debug"}],"output":{"name":"debugset"}}],[11,"entries","","Adds the contents of an iterator of entries to the set output.",220,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"debugset"}}],[11,"finish","","Finishes output and returns any error encountered.",220,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"field","","Adds a new field to the generated tuple struct output.",221,{"inputs":[{"name":"self"},{"name":"debug"}],"output":{"name":"debugtuple"}}],[11,"finish","","Finishes output and returns any error encountered.",221,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"field","","Adds a new field to the generated struct output.",222,{"inputs":[{"name":"self"},{"name":"str"},{"name":"debug"}],"output":{"name":"debugstruct"}}],[11,"finish","","Finishes output and returns any error encountered.",222,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"entry","","Adds a new entry to the map output.",223,{"inputs":[{"name":"self"},{"name":"debug"},{"name":"debug"}],"output":{"name":"debugmap"}}],[11,"entries","","Adds the contents of an iterator of entries to the map output.",223,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"debugmap"}}],[11,"finish","","Finishes output and returns any error encountered.",223,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"unpaired_surrogate","std::char","Returns the unpaired surrogate which caused this error.",215,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"valid_up_to","std::str","Returns the index in the given string up to which valid UTF-8 was verified.",161,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"error_len","","Provide more information about the failure:",161,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"option"}}],[11,"as_str","","View the underlying data as a subslice of the original data.",148,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"as_str","","View the underlying data as a subslice of the original data.",127,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"as_slice","std::slice","View the underlying data as a subslice of the original data.",137,null],[11,"into_slice","","View the underlying data as a subslice of the original data.",188,null],[11,"new","std::sync::atomic","Creates a new `AtomicBool`.",201,{"inputs":[{"name":"bool"}],"output":{"name":"atomicbool"}}],[11,"get_mut","","Returns a mutable reference to the underlying [`bool`].",201,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",201,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"load","","Loads a value from the bool.",201,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"store","","Stores a value into the bool.",201,null],[11,"swap","","Stores a value into the bool, returning the previous value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"compare_and_swap","","Stores a value into the [`bool`] if the current value is the same as the `current` value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"compare_exchange","","Stores a value into the [`bool`] if the current value is the same as the `current` value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["bool","bool"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the [`bool`] if the current value is the same as the `current` value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["bool","bool"],"name":"result"}}],[11,"fetch_and","","Logical \"and\" with a boolean value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"fetch_nand","","Logical \"nand\" with a boolean value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"fetch_or","","Logical \"or\" with a boolean value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"fetch_xor","","Logical \"xor\" with a boolean value.",201,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"ordering"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `AtomicPtr`.",205,null],[11,"get_mut","","Returns a mutable reference to the underlying pointer.",205,null],[11,"into_inner","","Consumes the atomic and returns the contained value.",205,null],[11,"load","","Loads a value from the pointer.",205,null],[11,"store","","Stores a value into the pointer.",205,null],[11,"swap","","Stores a value into the pointer, returning the previous value.",205,null],[11,"compare_and_swap","","Stores a value into the pointer if the current value is the same as the `current` value.",205,null],[11,"compare_exchange","","Stores a value into the pointer if the current value is the same as the `current` value.",205,null],[11,"compare_exchange_weak","","Stores a value into the pointer if the current value is the same as the `current` value.",205,null],[11,"new","","Creates a new atomic integer.",194,{"inputs":[{"name":"i8"}],"output":{"name":"atomici8"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",194,{"inputs":[{"name":"self"}],"output":{"name":"i8"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",194,{"inputs":[{"name":"self"}],"output":{"name":"i8"}}],[11,"load","","Loads a value from the atomic integer.",194,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"store","","Stores a value into the atomic integer.",194,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"i8"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i8","i8"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"i8"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i8","i8"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",194,{"inputs":[{"name":"self"},{"name":"i8"},{"name":"ordering"}],"output":{"name":"i8"}}],[11,"new","","Creates a new atomic integer.",206,{"inputs":[{"name":"u8"}],"output":{"name":"atomicu8"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",206,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",206,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"load","","Loads a value from the atomic integer.",206,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"store","","Stores a value into the atomic integer.",206,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"u8"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u8","u8"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"u8"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u8","u8"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",206,{"inputs":[{"name":"self"},{"name":"u8"},{"name":"ordering"}],"output":{"name":"u8"}}],[11,"new","","Creates a new atomic integer.",203,{"inputs":[{"name":"i16"}],"output":{"name":"atomici16"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",203,{"inputs":[{"name":"self"}],"output":{"name":"i16"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",203,{"inputs":[{"name":"self"}],"output":{"name":"i16"}}],[11,"load","","Loads a value from the atomic integer.",203,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"store","","Stores a value into the atomic integer.",203,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"i16"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i16","i16"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"i16"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i16","i16"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",203,{"inputs":[{"name":"self"},{"name":"i16"},{"name":"ordering"}],"output":{"name":"i16"}}],[11,"new","","Creates a new atomic integer.",202,{"inputs":[{"name":"u16"}],"output":{"name":"atomicu16"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",202,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",202,{"inputs":[{"name":"self"}],"output":{"name":"u16"}}],[11,"load","","Loads a value from the atomic integer.",202,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"store","","Stores a value into the atomic integer.",202,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u16","u16"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"u16"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u16","u16"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",202,{"inputs":[{"name":"self"},{"name":"u16"},{"name":"ordering"}],"output":{"name":"u16"}}],[11,"new","","Creates a new atomic integer.",196,{"inputs":[{"name":"i32"}],"output":{"name":"atomici32"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",196,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",196,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"load","","Loads a value from the atomic integer.",196,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"store","","Stores a value into the atomic integer.",196,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"i32"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i32","i32"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"i32"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i32","i32"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",196,{"inputs":[{"name":"self"},{"name":"i32"},{"name":"ordering"}],"output":{"name":"i32"}}],[11,"new","","Creates a new atomic integer.",204,{"inputs":[{"name":"u32"}],"output":{"name":"atomicu32"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",204,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",204,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"load","","Loads a value from the atomic integer.",204,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"store","","Stores a value into the atomic integer.",204,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u32"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u32","u32"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u32"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u32","u32"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",204,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"ordering"}],"output":{"name":"u32"}}],[11,"new","","Creates a new atomic integer.",200,{"inputs":[{"name":"i64"}],"output":{"name":"atomici64"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",200,{"inputs":[{"name":"self"}],"output":{"name":"i64"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",200,{"inputs":[{"name":"self"}],"output":{"name":"i64"}}],[11,"load","","Loads a value from the atomic integer.",200,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"store","","Stores a value into the atomic integer.",200,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"i64"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i64","i64"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"i64"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["i64","i64"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",200,{"inputs":[{"name":"self"},{"name":"i64"},{"name":"ordering"}],"output":{"name":"i64"}}],[11,"new","","Creates a new atomic integer.",198,{"inputs":[{"name":"u64"}],"output":{"name":"atomicu64"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",198,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",198,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"load","","Loads a value from the atomic integer.",198,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"store","","Stores a value into the atomic integer.",198,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u64"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u64","u64"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u64"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["u64","u64"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",198,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"ordering"}],"output":{"name":"u64"}}],[11,"new","","Creates a new atomic integer.",195,{"inputs":[{"name":"isize"}],"output":{"name":"atomicisize"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",195,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",195,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"load","","Loads a value from the atomic integer.",195,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"store","","Stores a value into the atomic integer.",195,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"isize"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["isize","isize"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"isize"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["isize","isize"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",195,{"inputs":[{"name":"self"},{"name":"isize"},{"name":"ordering"}],"output":{"name":"isize"}}],[11,"new","","Creates a new atomic integer.",197,{"inputs":[{"name":"usize"}],"output":{"name":"atomicusize"}}],[11,"get_mut","","Returns a mutable reference to the underlying integer.",197,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"into_inner","","Consumes the atomic and returns the contained value.",197,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"load","","Loads a value from the atomic integer.",197,{"inputs":[{"name":"self"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"store","","Stores a value into the atomic integer.",197,null],[11,"swap","","Stores a value into the atomic integer, returning the previous value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"compare_and_swap","","Stores a value into the atomic integer if the current value is the same as the `current` value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"compare_exchange","","Stores a value into the atomic integer if the current value is the same as the `current` value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["usize","usize"],"name":"result"}}],[11,"compare_exchange_weak","","Stores a value into the atomic integer if the current value is the same as the `current` value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"ordering"},{"name":"ordering"}],"output":{"generics":["usize","usize"],"name":"result"}}],[11,"fetch_add","","Adds to the current value, returning the previous value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"fetch_sub","","Subtracts from the current value, returning the previous value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"fetch_and","","Bitwise \"and\" with the current value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"fetch_or","","Bitwise \"or\" with the current value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}],[11,"fetch_xor","","Bitwise \"xor\" with the current value.",197,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"ordering"}],"output":{"name":"usize"}}]],"paths":[[8,"Any"],[8,"Clone"],[8,"PartialEq"],[4,"Ordering"],[3,"Reverse"],[8,"Ord"],[8,"PartialOrd"],[8,"AsRef"],[8,"AsMut"],[8,"Into"],[8,"From"],[8,"TryInto"],[8,"TryFrom"],[8,"Default"],[8,"Hash"],[8,"Hasher"],[8,"BuildHasher"],[8,"Iterator"],[8,"FromIterator"],[8,"IntoIterator"],[8,"Step"],[8,"DoubleEndedIterator"],[8,"Product"],[8,"Extend"],[8,"Sum"],[8,"ExactSizeIterator"],[8,"Shr"],[4,"GeneratorState"],[3,"RangeInclusive"],[8,"IndexMut"],[8,"Placer"],[8,"Fn"],[8,"BitXor"],[8,"DerefMut"],[8,"Try"],[8,"Place"],[8,"BitOr"],[8,"Mul"],[8,"Index"],[8,"RemAssign"],[8,"Add"],[8,"BoxPlace"],[8,"BitAnd"],[8,"Generator"],[8,"Sub"],[8,"Neg"],[8,"ShlAssign"],[8,"FnMut"],[8,"ShrAssign"],[8,"Boxed"],[8,"Shl"],[3,"RangeFrom"],[8,"SubAssign"],[8,"DivAssign"],[8,"Deref"],[8,"BitOrAssign"],[8,"InPlace"],[3,"Range"],[8,"MulAssign"],[8,"AddAssign"],[8,"BitAndAssign"],[8,"Rem"],[3,"RangeToInclusive"],[8,"Drop"],[8,"BitXorAssign"],[8,"Not"],[8,"FnOnce"],[3,"RangeTo"],[8,"Div"],[3,"TraitObject"],[4,"Result"],[4,"Option"],[4,"Alignment"],[8,"Write"],[8,"Debug"],[8,"Display"],[8,"Octal"],[8,"Binary"],[8,"LowerHex"],[8,"UpperHex"],[8,"Pointer"],[8,"LowerExp"],[8,"UpperExp"],[3,"UnicodeVersion"],[8,"SliceExt"],[8,"FromStr"],[8,"Pattern"],[4,"SearchStep"],[8,"Searcher"],[8,"ReverseSearcher"],[3,"EncodeUtf16"],[8,"SliceIndex"],[8,"SliceConcatExt"],[4,"ErrorKind"],[4,"SeekFrom"],[4,"CharsError"],[3,"Cursor"],[3,"Error"],[3,"Empty"],[3,"Repeat"],[3,"Sink"],[8,"Read"],[8,"Write"],[8,"Seek"],[8,"BufRead"],[3,"Initializer"],[3,"Chain"],[3,"Take"],[3,"Bytes"],[3,"Chars"],[4,"Ordering"],[3,"TypeId"],[3,"Windows"],[3,"SplitTerminator"],[3,"LinesAny"],[3,"Arguments"],[3,"IntoIter"],[3,"CharSearcher"],[3,"Cell"],[3,"Take"],[3,"Lines"],[3,"RSplitN"],[3,"Chunks"],[3,"TakeWhile"],[3,"Map"],[3,"CharTryFromError"],[4,"Infallible"],[3,"CharIndices"],[3,"Empty"],[3,"CharPredicateSearcher"],[3,"SipHasher13"],[3,"CharSliceSearcher"],[3,"Cycle"],[3,"RSplit"],[3,"Once"],[3,"Peekable"],[3,"MatchIndices"],[3,"Iter"],[3,"Cloned"],[3,"Iter"],[3,"IntoIter"],[3,"NoneError"],[3,"Fuse"],[3,"ParseBoolError"],[3,"FlatMap"],[3,"RangeFull"],[3,"PhantomData"],[3,"ParseCharError"],[3,"Chars"],[3,"RSplitTerminator"],[3,"Shared"],[3,"RefCell"],[3,"SplitN"],[3,"RMatches"],[3,"Discriminant"],[3,"Enumerate"],[3,"SkipWhile"],[3,"StepBy"],[3,"DecodeUtf8"],[3,"Skip"],[3,"Chain"],[3,"Utf8Error"],[3,"SipHasher24"],[3,"RSplit"],[3,"EscapeDebug"],[3,"Filter"],[3,"FilterMap"],[3,"StrSearcher"],[3,"Scan"],[3,"SipHasher"],[3,"Split"],[3,"Inspect"],[3,"Zip"],[3,"Iter"],[3,"Rev"],[3,"Unique"],[3,"EscapeDefault"],[3,"Bytes"],[3,"Error"],[3,"BuildHasherDefault"],[3,"RMatchIndices"],[19,"ManuallyDrop"],[3,"Split"],[3,"Repeat"],[3,"EscapeUnicode"],[3,"Matches"],[3,"Ref"],[3,"RefMut"],[3,"IterMut"],[3,"IterMut"],[3,"ChunksMut"],[3,"IterMut"],[3,"RSplitMut"],[3,"SplitMut"],[3,"AtomicI8"],[3,"AtomicIsize"],[3,"AtomicI32"],[3,"AtomicUsize"],[3,"AtomicU64"],[3,"UnsafeCell"],[3,"AtomicI64"],[3,"AtomicBool"],[3,"AtomicU16"],[3,"AtomicI16"],[3,"AtomicU32"],[3,"AtomicPtr"],[3,"AtomicU8"],[3,"BorrowMutError"],[3,"RSplitNMut"],[3,"SplitN"],[3,"SplitNMut"],[3,"BorrowError"],[3,"RSplitN"],[3,"Formatter"],[3,"SplitWhitespace"],[3,"DecodeUtf16Error"],[3,"DecodeUtf16"],[3,"ToLowercase"],[3,"ToUppercase"],[3,"DebugList"],[3,"DebugSet"],[3,"DebugTuple"],[3,"DebugStruct"],[3,"DebugMap"]]};
initSearch(searchIndex);
